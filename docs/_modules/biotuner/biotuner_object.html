
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>biotuner.biotuner_object &#8212; Biotuner 0.0.16 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/example_gallery_styles.css?v=df915669" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=baac2cea"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/biotuner/biotuner_object';</script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="0.0.16" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Biotuner 0.0.16 documentation - Home"/>
    <img src="../../_static/logo.png" class="logo__image only-dark pst-js-only" alt="Biotuner 0.0.16 documentation - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Menu:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started with Biotuner</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite_us.html">Cite us</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../examples/index.html">Examples</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/biotuner_MNE/biotuner_MNE.html">Harmonicity Metrics Computation on MNE Epochs File</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/peaks_extraction/peaks_extraction.html">Peaks extraction methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/harmonicity_metrics/harmonicity_metrics.html">Harmonicity metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/harmonic_spectrum/harmonic_spectrum.html">From Spectral Peaks to Harmonic Spectrum Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/toolbox_paper_notebook/toolbox_paper_notebook.html">Biotuner Paper Design and Implementation Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/toolbox_paper_result_notebook/toolbox_paper_result_notebook.html">Biotuner Toolbox Paper Results Figures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/scale_construction/scale_construction.html">Constructing musical tunings with biosignals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/spectral_chords/spectral_chords.html">Deriving spectral chords from biosignals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/rhythm_construction/rhythm_construction.html">Constructing euclidian rhythms from biotunings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/phase_amplitude_coupling/phase_amplitude_coupling.html">Phase-Amplitude Coupling</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../api/index.html">API</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/biotuner_object.html">Biotuner object</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/metrics.html">Harmonicity Metrics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/peaks_extraction.html">Peaks Extraction</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/peaks_extension.html">Peaks Extension</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/harmonic_spectrum.html">Harmonic spectrum</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/harmonic_connectivity.html">Harmonic connectivity</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/transitional_harmony.html">Transitional Harmony</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/scale_construction.html">Scale construction</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/rhythm_construction.html">Rhythm construction</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../api/utils.html">Biotuner utilities</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for biotuner.biotuner_object</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">fooof</span><span class="w"> </span><span class="kn">import</span> <span class="n">FOOOF</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">emd</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.peaks_extraction</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">HilbertHuang1D</span><span class="p">,</span>
    <span class="n">harmonic_recurrence</span><span class="p">,</span>
    <span class="n">cepstrum</span><span class="p">,</span>
    <span class="n">cepstral_peaks</span><span class="p">,</span>
    <span class="n">EMD_eeg</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.peaks_extraction</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">extract_welch_peaks</span><span class="p">,</span>
    <span class="n">compute_FOOOF</span><span class="p">,</span>
    <span class="n">polyspectrum_frequencies</span><span class="p">,</span>
    <span class="n">pac_frequencies</span><span class="p">,</span>
    <span class="n">endogenous_intermodulations</span><span class="p">,</span>
    <span class="n">polycoherence</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.biotuner_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">flatten</span><span class="p">,</span>
    <span class="n">pairs_most_frequent</span><span class="p">,</span>
    <span class="n">compute_peak_ratios</span><span class="p">,</span>
    <span class="n">alpha2bands</span><span class="p">,</span>
    <span class="n">rebound</span><span class="p">,</span>
    <span class="n">prime_factor</span><span class="p">,</span>
    <span class="n">peaks_to_amps</span><span class="p">,</span>
    <span class="n">EMD_to_spectromorph</span><span class="p">,</span>
    <span class="n">ratios_harmonics</span><span class="p">,</span>
    <span class="n">ratios_increments</span><span class="p">,</span>
    <span class="n">make_chord</span><span class="p">,</span>
    <span class="n">scale_from_pairs</span><span class="p">,</span>
    <span class="n">ratios2cents</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">euler</span><span class="p">,</span>
    <span class="n">tenneyHeight</span><span class="p">,</span>
    <span class="n">timepoint_consonance</span><span class="p">,</span>
    <span class="n">ratios2harmsim</span><span class="p">,</span>
    <span class="n">compute_subharmonic_tension</span><span class="p">,</span>
    <span class="n">dyad_similarity</span><span class="p">,</span>
    <span class="n">consonant_ratios</span><span class="p">,</span>
    <span class="n">tuning_to_metrics</span><span class="p">,</span>
    <span class="n">consonance_peaks</span><span class="p">,</span>
    <span class="n">integral_tenneyHeight</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.peaks_extension</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">harmonic_fit</span><span class="p">,</span>
    <span class="n">multi_consonance</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.scale_construction</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">diss_curve</span><span class="p">,</span>
    <span class="n">harmonic_entropy</span><span class="p">,</span>
    <span class="n">harmonic_tuning</span><span class="p">,</span>
    <span class="n">euler_fokker_scale</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.rhythm_construction</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">scale2euclid</span><span class="p">,</span>
    <span class="n">consonant_euclid</span><span class="p">,</span>
    <span class="n">interval_vector</span><span class="p">,</span>
    <span class="n">interval_vec_to_string</span><span class="p">,</span>
    <span class="n">euclid_string_to_referent</span><span class="p">,</span>
    <span class="n">find_optimal_offsets</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.vizs</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">visualize_rhythms</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.dictionaries</span><span class="w"> </span><span class="kn">import</span> <span class="n">dict_rhythms</span><span class="p">,</span> <span class="n">interval_names</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">biotuner.vizs</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">graph_psd_peaks</span><span class="p">,</span>
    <span class="n">graphEMD_welch</span><span class="p">,</span>
    <span class="n">graph_harm_peaks</span><span class="p">,</span>
    <span class="n">EMD_PSD_graph</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sbn</span>


<div class="viewcode-block" id="compute_biotuner">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">compute_biotuner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used to derive peaks information, musical tunings, rhythms</span>
<span class="sd">    and related harmonicity metrics from time series (EEG, ECG, EMG,</span>
<span class="sd">    gravitational waves, noise, ...)</span>

<span class="sd">    Basic usage</span>
<span class="sd">    -----------</span>
<span class="sd">    &gt;&gt;&gt; biotuning = compute_biotuner(sf = 1000)</span>
<span class="sd">    &gt;&gt;&gt; biotuning.peaks_extraction(data)</span>
<span class="sd">    &gt;&gt;&gt; biotuning.peaks_extension()</span>
<span class="sd">    &gt;&gt;&gt; biotuning.peaks_metrics()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sf: int</span>
<span class="sd">        Sampling frequency (in Hz)</span>
<span class="sd">    data : array (numDataPoints,)</span>
<span class="sd">        Time series to analyze.</span>
<span class="sd">    peaks_function: str, default=&#39;EMD&#39;</span>
<span class="sd">        Defines the method to use for peak extraction.</span>

<span class="sd">        &#39;NON-HARMONIC PEAK EXTRACTIONS&#39;</span>
<span class="sd">            &#39;fixed&#39; :</span>
<span class="sd">                    Power Spectrum Density (PSD) estimated using Welch&#39;s method</span>
<span class="sd">                    on fixed frequency bands. Peaks correspond to frequency bins</span>
<span class="sd">                    with the highest power.</span>
<span class="sd">            &#39;adapt&#39; :</span>
<span class="sd">                    PSD estimated using Welch&#39;s method on each frequency band</span>
<span class="sd">                    derived from the alpha peak position. Peaks correspond to</span>
<span class="sd">                    frequency bins with the highest power.</span>
<span class="sd">            &#39;FOOOF&#39; :</span>
<span class="sd">                    PSD is estimated with Welch&#39;s method. &#39;FOOOF&#39; is applied to</span>
<span class="sd">                    remove the aperiodic component and find physiologically</span>
<span class="sd">                    relevant spectral peaks.</span>

<span class="sd">        &#39;SIGNAL DECOMPOSITION BASED PEAK EXTRACTION&#39;</span>
<span class="sd">            &#39;EMD&#39;:</span>
<span class="sd">                Intrinsic Mode Functions (IMFs) are derived with Empirical</span>
<span class="sd">                Mode Decomposition (EMD) PSD is computed on each IMF using</span>
<span class="sd">                Welch. Peaks correspond to frequency bins with the highest power.</span>
<span class="sd">            &#39;EEMD&#39; :</span>
<span class="sd">                    Intrinsic Mode Functions (IMFs) are derived with Ensemble</span>
<span class="sd">                    Empirical Mode Decomposition (EEMD). PSD is computed on each</span>
<span class="sd">                    IMF using Welch. Peaks correspond to frequency bins with the</span>
<span class="sd">                    highest power.</span>
<span class="sd">            &#39;CEEMDAN&#39; : Intrinsic Mode Functions (IMFs) are derived with Complex</span>
<span class="sd">                        Ensemble Empirical Mode Decomposition with Adaptive</span>
<span class="sd">                        Noise (CEEMDAN). PSD is computed on each IMF using Welch.</span>
<span class="sd">            &#39;EMD_FOOOF&#39; :</span>
<span class="sd">                        Intrinsic Mode Functions (IMFs) are derived with</span>
<span class="sd">                        Ensemble Empirical Mode Decomposition (EEMD). PSD is</span>
<span class="sd">                        computed on each IMF with Welch&#39;s method. &#39;FOOOF&#39; is</span>
<span class="sd">                        applied to remove the aperiodic component and find</span>
<span class="sd">                        physiologically relevant spectral peaks.</span>
<span class="sd">            &#39;HH1D_max&#39; :</span>
<span class="sd">                        Maximum values of the 1D Hilbert-Huang transform on each</span>
<span class="sd">                        IMF using EMD.</span>
<span class="sd">            &#39;HH1D_FOOOF&#39; :</span>
<span class="sd">                        TODO. Hilbert-Huang transform on each IMF with Welch&#39;s method</span>
<span class="sd">                        &#39;FOOOF&#39; is applied to remove the aperiodic component and</span>
<span class="sd">                        find physiologically relevant spectral peaks.</span>
<span class="sd">            &#39;SSA&#39; :</span>
<span class="sd">                    TODO. Singular Spectrum Analysis. The name &quot;singular spectrum</span>
<span class="sd">                    analysis&quot; relates to the spectrum of eigenvalues in a singular</span>
<span class="sd">                    value decomposition of a covariance matrix.</span>

<span class="sd">        &#39;SECOND-ORDER STATISTICAL PEAK EXTRACTION&#39;</span>
<span class="sd">            &#39;cepstrum&#39;:</span>
<span class="sd">                        Peak frequencies of the cepstrum (inverse Fourier transform</span>
<span class="sd">                        (IFT) of the logarithm of the estimated signal spectrum).</span>
<span class="sd">            &#39;HPS (to come)&#39; :</span>
<span class="sd">                    Harmonic Product Spectrum (HPS) corresponds to the product of</span>
<span class="sd">                    the spectral power at each harmonic. Peaks correspond to the</span>
<span class="sd">                    frequency bins with the highest value of the HPS.</span>
<span class="sd">            &#39;Harmonic_salience (to come)&#39; :</span>
<span class="sd">                                A measure of harmonic salience computed by taking</span>
<span class="sd">                                the sum of the squared cosine of the angle between</span>
<span class="sd">                                a harmonic and its neighbors.</span>

<span class="sd">        &#39;CROSS-FREQUENCY COUPLING BASED PEAK EXTRACTION&#39;</span>
<span class="sd">            &#39;Bicoherence&#39; :</span>
<span class="sd">                            Corresponds to the normalized cross-bispectrum.</span>
<span class="sd">                            It is a third-order moment in the frequency domain.</span>
<span class="sd">                            It is a measure of phase-amplitude coupling.</span>
<span class="sd">            &#39;PAC&#39; :</span>
<span class="sd">                    Phase-amplitude coupling. A measure of phase-amplitude</span>
<span class="sd">                    coupling between low-frequency phase and high-frequency</span>
<span class="sd">                    amplitude.</span>

<span class="sd">        &#39;PEAK SELECTION BASED ON HARMONIC PROPERTIES&#39;</span>
<span class="sd">            &#39;EIMC&#39; :</span>
<span class="sd">                    Endogenous InterModulation Components (EIMC)</span>
<span class="sd">                    correspond to spectral peaks that are sums or differences</span>
<span class="sd">                    of other peaks harmonics (f1+f2, f1+2f2, f1-f2, f1-2f2...).</span>
<span class="sd">                    PSD is estimated with Welch&#39;s method. All peaks are extracted.</span>
<span class="sd">            &#39;harmonic_recurrence&#39; :</span>
<span class="sd">                            PSD is estimated with Welch&#39;s method.</span>
<span class="sd">                            All peaks are extracted. Peaks for which</span>
<span class="sd">                            other peaks are their harmonics are kept.</span>

<span class="sd">        &#39;PEAKS EXTRACTION PARAMETERS&#39;</span>

<span class="sd">    precision: float, default=0.1</span>
<span class="sd">        Precision of the peaks (in Hz).</span>
<span class="sd">        When HH1D_max is used, bins are in log scale by default.</span>
<span class="sd">    compute_sub_ratios: bool, default=False</span>
<span class="sd">        When set to True, include ratios &lt; 1 in peaks_ratios attribute.</span>
<span class="sd">    scale_cons_limit: float, default=0.1</span>
<span class="sd">        The minimal value of consonance needed for a peaks ratio to be</span>
<span class="sd">        included in the peaks_ratios_cons attribute.</span>

<span class="sd">        &#39;EXTENDED PEAKS PARAMETERS&#39;</span>

<span class="sd">    n_harm: int, default=10</span>
<span class="sd">        Set the number of harmonics to compute in harmonic_fit function.</span>
<span class="sd">    harm_function: str, default=&#39;mult&#39;</span>
<span class="sd">        - &#39;mult&#39; : Computes harmonics from iterative multiplication</span>
<span class="sd">                   (x, 2x, 3x...)</span>
<span class="sd">        - &#39;div&#39;: Computes harmonics from iterative division (x, x/2, x/3...).</span>
<span class="sd">    extension_method: str, default=&#39;consonant_harmonic_fit&#39;</span>

<span class="sd">        - &#39;consonant_harmonic_fit&#39; : computes the best-fit of harmonic peaks</span>
<span class="sd">           according to consonance intervals (eg. octaves, fifths).</span>
<span class="sd">        - &#39;all_harmonic_fit&#39; : computes the best-fit of harmonic peaks without</span>
<span class="sd">           considering consonance intervals.</span>

<span class="sd">        &#39;RATIOS EXTENSION PARAMETERS&#39;</span>

<span class="sd">    ratios_n_harms: int, default=5</span>
<span class="sd">        The number of harmonics used to compute extended peaks ratios.</span>
<span class="sd">    ratios_harms: bool, default=False</span>
<span class="sd">        When set to True, harmonics (x*1, x*2, x*3...,x*n) of specified</span>
<span class="sd">        ratios will be computed.</span>
<span class="sd">    ratios_inc: bool, default=True</span>
<span class="sd">        When set to True, exponentials (x**1, x**2, x**3,...x**n) of</span>
<span class="sd">        specified ratios will be computed.</span>
<span class="sd">    ratios_inc_fit: bool, Default=False</span>
<span class="sd">        When set to True, a fit between exponentials</span>
<span class="sd">        (x**1, x**2, x**3,...x**n) of specified ratios will be computed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sf</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">peaks_function</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">compute_sub_ratios</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">n_harm</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">harm_function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
        <span class="n">extension_method</span><span class="o">=</span><span class="s2">&quot;consonant_harmonic_fit&quot;</span><span class="p">,</span>
        <span class="n">ratios_n_harms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">ratios_harms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ratios_inc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ratios_inc_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scale_cons_limit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame_lib</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Initializing data</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="c1"># squeeze data if it is a 2D array</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># check if data is a 1D array</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be a 1D array&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span>
        <span class="c1"># Initializing arguments for peak extraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span> <span class="o">=</span> <span class="n">peaks_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_sub_ratios</span> <span class="o">=</span> <span class="n">compute_sub_ratios</span>
        <span class="c1"># Initializing arguments for peaks metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span> <span class="o">=</span> <span class="n">n_harm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">harm_function</span> <span class="o">=</span> <span class="n">harm_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extension_method</span> <span class="o">=</span> <span class="n">extension_method</span>
        <span class="c1"># Initializing dictionary for scales metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_cons_limit</span> <span class="o">=</span> <span class="n">scale_cons_limit</span>
        <span class="c1"># Initializing arguments for ratios extension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratios_n_harms</span> <span class="o">=</span> <span class="n">ratios_n_harms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratios_harms</span> <span class="o">=</span> <span class="n">ratios_harms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratios_inc</span> <span class="o">=</span> <span class="n">ratios_inc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratios_inc_fit</span> <span class="o">=</span> <span class="n">ratios_inc_fit</span>

<div class="viewcode-block" id="compute_biotuner.peaks_extraction">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.peaks_extraction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">peaks_extraction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">peaks_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
        <span class="n">min_harms</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">compute_sub_ratios</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ratios_extension</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ratios_n_harms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_cons_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">octave</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">harm_limit</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
        <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">prominence</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">rel_height</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
        <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_harm_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">EIMC_order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">min_IMs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">smooth_fft</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_first_IMF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">identify_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The peaks_extraction method is central to the use of the Biotuner.</span>
<span class="sd">        It uses a time series as input and extract spectral peaks based on</span>
<span class="sd">        a variety of methods. See peaks_function parameter description</span>
<span class="sd">        in __init__ function for more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: array (numDataPoints,)</span>
<span class="sd">            biosignal to analyse</span>
<span class="sd">        peaks_function: str</span>
<span class="sd">            refer to __init__</span>
<span class="sd">        FREQ_BANDS: List of lists of float</span>
<span class="sd">            Each list within the list of lists sets the lower and</span>
<span class="sd">            upper limit of a frequency band</span>
<span class="sd">        precision: float, default=0.1 -&gt; __init__</span>
<span class="sd">            Precision of the peaks (in Hz)</span>
<span class="sd">            When HH1D_max is used, bins are in log scale.</span>
<span class="sd">        sf: int</span>
<span class="sd">            Sampling frequency (in Hertz).</span>
<span class="sd">        min_freq: float, default=1</span>
<span class="sd">            minimum frequency value to be considered as a peak</span>
<span class="sd">            Used with &#39;harmonic_recurrence&#39; and &#39;HH1D_max&#39; peaks functions</span>
<span class="sd">        max_freq: float, default=60</span>
<span class="sd">            maximum frequency value to be considered as a peak</span>
<span class="sd">            Used with &#39;harmonic_recurrence&#39; and &#39;HH1D_max&#39; peaks functions</span>
<span class="sd">        min_harms: int, default=2</span>
<span class="sd">            minimum number of harmonics to consider a peak frequency using</span>
<span class="sd">            the &#39;harmonic_recurrence&#39; function.</span>
<span class="sd">        compute_sub_ratios: Boolean, default=False</span>
<span class="sd">            If set to True, will include peaks ratios (x/y) when x &lt; y</span>
<span class="sd">        ratios_extension: Boolean, default=False</span>
<span class="sd">            When set to True, peaks_ratios harmonics and</span>
<span class="sd">            increments are computed.</span>
<span class="sd">        ratios_n_harms: int, default=5 -&gt; __init__</span>
<span class="sd">            number of harmonics or increments to use in ratios_extension method</span>
<span class="sd">        scale_cons_limit: float, default=0.1</span>
<span class="sd">            minimal value of consonance to be reach for a peaks ratio</span>
<span class="sd">            to be included in the peaks_ratios_cons attribute.</span>
<span class="sd">        octave: float, default=2</span>
<span class="sd">            value of the octave</span>
<span class="sd">        harm_limit: int, default=128</span>
<span class="sd">            Maximum harmonic position for &#39;harmonic_recurrence&#39; method.</span>
<span class="sd">        n_peaks: int, default=5</span>
<span class="sd">            Number of peaks when using &#39;FOOOF&#39; and &#39;cepstrum&#39;,</span>
<span class="sd">            and &#39;harmonic_recurrence&#39; functions.</span>
<span class="sd">            Peaks are chosen based on their amplitude.</span>
<span class="sd">        prominence: float, default=1.0</span>
<span class="sd">            Minimum prominence of peaks.</span>
<span class="sd">        rel_height: float, default=0.7</span>
<span class="sd">            Minimum relative height of peaks.</span>
<span class="sd">        nIMFs: int, default=5</span>
<span class="sd">            Number of intrinsic mode functions to keep when using</span>
<span class="sd">            &#39;EEMD&#39; or &#39;EMD&#39; peaks function.</span>
<span class="sd">        graph: boolean, default=False</span>
<span class="sd">            When set to True, a graph will accompanies the peak extraction</span>
<span class="sd">            method (except for &#39;fixed&#39; and &#39;adapt&#39;).</span>
<span class="sd">        nperseg : int, default=None</span>
<span class="sd">            Length of each segment.</span>
<span class="sd">            If None, nperseg = nfft/smooth</span>
<span class="sd">        nfft : int, default=None</span>
<span class="sd">            Length of the FFT used, if a zero padded FFT is desired.</span>
<span class="sd">            If None, nfft = sf/(1/precision)</span>
<span class="sd">        noverlap : int, default=None</span>
<span class="sd">            Number of points to overlap between segments.</span>
<span class="sd">            If None, noverlap = nperseg // 2.</span>
<span class="sd">        max_harm_freq : int, default=None</span>
<span class="sd">            Maximum frequency value of the find peaks function</span>
<span class="sd">            when harmonic_recurrence or EIMC peaks extraction method is used.</span>
<span class="sd">        EIMC_order : int, default=3</span>
<span class="sd">            Maximum order of the Intermodulation Components.</span>
<span class="sd">        min_IMs : int, default=2</span>
<span class="sd">            Minimal number of Intermodulation Components to select the</span>
<span class="sd">            associated pair of peaks.</span>
<span class="sd">        smooth_fft : int, default=1</span>
<span class="sd">            Number used to divide nfft to derive nperseg.</span>
<span class="sd">        verbose : boolean, default=True</span>
<span class="sd">            When set to True, number of detected peaks will be displayed.</span>
<span class="sd">        keep_first_IMF : boolean, default=False</span>
<span class="sd">            When set to True, the first IMF is kept.</span>
<span class="sd">        identify_labels : boolean, default=False</span>
<span class="sd">            When set to True, the labels of peaks ratios will be identified</span>
<span class="sd">            from the interval_names dictionary.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.peaks: array (float)</span>
<span class="sd">            1D array of peaks frequencies</span>
<span class="sd">        self.amps: array (float)</span>
<span class="sd">            1D array of peaks amplitudes</span>
<span class="sd">        self.peaks_ratios: array (float)</span>
<span class="sd">            1D array of peaks ratios</span>
<span class="sd">        self.peaks_ratios_cons: array (float)</span>
<span class="sd">            1D array of peaks ratios when more consonant than</span>
<span class="sd">            scale_cons_limit parameter.</span>
<span class="sd">        .. note::</span>
<span class="sd">        The following attributes are only present if `ratios_extension = True`:</span>

<span class="sd">        self.peaks_ratios_harm: List (float)</span>
<span class="sd">            List of peaks ratios and their harmonics</span>
<span class="sd">        self.peaks_ratios_inc: List (float)</span>
<span class="sd">            List of peaks ratios and their increments (ratios**n)</span>
<span class="sd">        self.peaks_ratios_inc_bound: List (float)</span>
<span class="sd">            List of peaks ratios and their increments (ratios**n)</span>
<span class="sd">            bound within one octave</span>
<span class="sd">        self.peaks_ratios_inc_fit: List (float)</span>
<span class="sd">            List of peaks ratios and their congruent increments (ratios**n)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">peaks_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span>
        <span class="k">if</span> <span class="n">compute_sub_ratios</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">compute_sub_ratios</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_sub_ratios</span>
        <span class="k">if</span> <span class="n">scale_cons_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_cons_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_cons_limit</span>
        <span class="k">if</span> <span class="n">ratios_n_harms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratios_n_harms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios_n_harms</span>

        <span class="c1"># if data is list, convert to numpy array</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># check if data is empty array or list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data is empty&quot;</span><span class="p">)</span>
        <span class="c1"># squeeze data if it is a 2D array</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># check if data is a 1D array</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be a 1D array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># ensure peaks_function is in the list of available peaks functions</span>
        <span class="n">peaks_functions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;fixed&quot;</span><span class="p">,</span>
            <span class="s2">&quot;adapt&quot;</span><span class="p">,</span>
            <span class="s2">&quot;FOOOF&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EMD&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EEMD&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EMD_FOOOF&quot;</span><span class="p">,</span>
            <span class="s2">&quot;CEEMDAN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;HH1D_max&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cepstrum&quot;</span><span class="p">,</span>
            <span class="s2">&quot;harmonic_recurrence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bicoherence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PAC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EIMC&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">peaks_functions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;peaks_function must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">peaks_functions</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">octave</span> <span class="o">=</span> <span class="n">octave</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nIMFs</span> <span class="o">=</span> <span class="n">nIMFs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_sub_ratios</span> <span class="o">=</span> <span class="n">compute_sub_ratios</span>
        <span class="n">peaks</span><span class="p">,</span> <span class="n">amps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_peaks_ts</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">peaks_function</span><span class="o">=</span><span class="n">peaks_function</span><span class="p">,</span>
            <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
            <span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
            <span class="n">max_freq</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
            <span class="n">min_harms</span><span class="o">=</span><span class="n">min_harms</span><span class="p">,</span>
            <span class="n">harm_limit</span><span class="o">=</span><span class="n">harm_limit</span><span class="p">,</span>
            <span class="n">n_peaks</span><span class="o">=</span><span class="n">n_peaks</span><span class="p">,</span>
            <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span>
            <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
            <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
            <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
            <span class="n">max_harm_freq</span><span class="o">=</span><span class="n">max_harm_freq</span><span class="p">,</span>
            <span class="n">EIMC_order</span><span class="o">=</span><span class="n">EIMC_order</span><span class="p">,</span>
            <span class="n">min_IMs</span><span class="o">=</span><span class="n">min_IMs</span><span class="p">,</span>
            <span class="n">smooth_fft</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
            <span class="n">keep_first_IMF</span><span class="o">=</span><span class="n">keep_first_IMF</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of peaks : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No peak detected&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amps</span> <span class="o">=</span> <span class="n">amps</span>
        <span class="c1"># print(&quot;Number of peaks: &quot;, len(peaks))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios</span> <span class="o">=</span> <span class="n">compute_peak_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">,</span> <span class="n">rebound</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="n">compute_sub_ratios</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios_cons</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">consonant_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">scale_cons_limit</span><span class="p">)</span>

        <span class="c1"># find labels of peaks_ratios from the interval_names dictionary</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">find_interval</span><span class="p">(</span><span class="n">cents</span><span class="p">,</span> <span class="n">interval_names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">interval</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">interval_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;Cents&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cents</span><span class="p">:</span>
                    <span class="n">harmonic</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;Harmonic&quot;</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">interval</span><span class="p">,</span> <span class="n">harmonic</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">identify_labels</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios_labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cents</span> <span class="o">=</span> <span class="n">ratios2cents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">cent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cents</span><span class="p">):</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">harmonic</span> <span class="o">=</span> <span class="n">find_interval</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cent</span><span class="p">),</span> <span class="n">interval_names</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios_labels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ratios_extension</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios_extension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios</span><span class="p">,</span> <span class="n">ratios_n_harms</span><span class="o">=</span><span class="n">ratios_n_harms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios_harms</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios_inc</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">bound_</span> <span class="o">=</span> <span class="p">[</span><span class="n">rebound</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios_inc_bound</span> <span class="o">=</span> <span class="n">bound_</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios_inc_fit</span> <span class="o">=</span> <span class="n">c</span></div>


<div class="viewcode-block" id="compute_biotuner.peaks_extension">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.peaks_extension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">peaks_extension</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">peaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_harm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;harmonic_fit&quot;</span><span class="p">,</span>
        <span class="n">harm_function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
        <span class="n">div_mode</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span>
        <span class="n">cons_limit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">ratios_extension</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">harm_bounds</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">scale_cons_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to extend a set of frequencies based on the</span>
<span class="sd">        harmonic congruence of specific elements (extend). It can also</span>
<span class="sd">        restrict a set of frequencies based on the consonance level of</span>
<span class="sd">        specific peak frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peaks : List of float</span>
<span class="sd">            List of frequency peaks.</span>
<span class="sd">        n_harm: int, default=10</span>
<span class="sd">            Set the number of harmonics to compute in harmonic_fit function</span>
<span class="sd">        method: str, default=&#39;harmonic_fit&#39;</span>

<span class="sd">            - &#39;harmonic_fit&#39;</span>
<span class="sd">            - &#39;consonant&#39;</span>
<span class="sd">            - &#39;multi_consonant&#39;,</span>
<span class="sd">            - &#39;consonant_harmonic_fit&#39;</span>
<span class="sd">            - &#39;multi_consonant_harmonic_fit&#39;</span>

<span class="sd">        harm_function: str, default=&#39;mult&#39;</span>

<span class="sd">            - &#39;mult&#39; : Computes harmonics from iterative multiplication (x, 2x, 3x, ...nx)</span>
<span class="sd">            - &#39;div&#39; : Computes harmonics from iterative division (x, x/2, x/3, ...x/n)</span>

<span class="sd">        div_mode : strm default=&#39;add&#39;</span>
<span class="sd">            Defines the way the harmonics are computed when harm_function is &#39;div&#39;</span>

<span class="sd">            - &#39;div&#39;: x, x/2, x/3 ..., x/n</span>
<span class="sd">            - &#39;div_add&#39;: x, (x+x/2), (x+x/3), ... (x+x/n)</span>
<span class="sd">            - &#39;div_sub&#39;: x, (x-x/2), (x-x/3), ... (x-x/n)</span>

<span class="sd">        cons_limit : float</span>
<span class="sd">            Defines the minimal consonance level used in the method.</span>
<span class="sd">        ratios_extension : Boolean, default=False</span>
<span class="sd">            If is True, ratios_extensions are computed accordingly to what</span>
<span class="sd">            was defined in __init__.</span>
<span class="sd">        harm_bounds : float, default=0.1</span>
<span class="sd">            Maximal distance in Hertz between two frequencies to consider</span>
<span class="sd">            them as equivalent.</span>
<span class="sd">        scale_cons_limit : float, default=None</span>
<span class="sd">            Minimal value of consonance to be reach for a peaks ratio</span>
<span class="sd">            to be included in the extended_peaks_ratios_cons attribute.</span>
<span class="sd">            When None, scale_cons_limit = 0.1, as defined in __init__</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.extended_peaks: List (float)</span>
<span class="sd">            List of extended peaks frequencies.</span>
<span class="sd">        self.extended_amps: List (float)</span>
<span class="sd">            List of extended peaks amplitudes.</span>
<span class="sd">        self.extended_peaks_ratios : List (float)</span>
<span class="sd">            List of pairwise extended peaks ratios.</span>
<span class="sd">        self.extended_peaks_ratios_cons : List (float)</span>
<span class="sd">            List of pairwise extended peaks ratios when more consonant than</span>
<span class="sd">            scale_limit_cons parameter.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        .. note::</span>
<span class="sd">        The following attributes are only present if `ratios_extension = True`:</span>
<span class="sd">        self.peaks_ratios_harm: List (float)</span>
<span class="sd">            List of extended peaks ratios and their harmonics</span>
<span class="sd">        self.peaks_ratios_inc: List (float)</span>
<span class="sd">            List of extended peaks ratios and their increments (ratios**n)</span>
<span class="sd">        self.peaks_ratios_inc_fit: List (float)</span>
<span class="sd">            List of extended peaks ratios and</span>
<span class="sd">            their congruent increments (ratios**n).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">peaks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>
        <span class="k">if</span> <span class="n">n_harm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_harm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_method</span>
        <span class="k">if</span> <span class="n">scale_cons_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_cons_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_cons_limit</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;harmonic_fit&quot;</span><span class="p">:</span>
            <span class="n">extended_peaks</span><span class="p">,</span> <span class="n">harmonics</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span>
                <span class="n">peaks</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="p">,</span>
                <span class="n">function</span><span class="o">=</span><span class="n">harm_function</span><span class="p">,</span>
                <span class="n">div_mode</span><span class="o">=</span><span class="n">div_mode</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">harm_bounds</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">extended_peaks</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;consonant&quot;</span><span class="p">:</span>
            <span class="n">consonance</span><span class="p">,</span> <span class="n">cons_pairs</span><span class="p">,</span> <span class="n">cons_peaks</span><span class="p">,</span> <span class="n">cons_metric</span> <span class="o">=</span> <span class="n">consonance_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">cons_limit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">cons_peaks</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;multi_consonant&quot;</span><span class="p">:</span>
            <span class="n">consonance</span><span class="p">,</span> <span class="n">cons_pairs</span><span class="p">,</span> <span class="n">cons_peaks</span><span class="p">,</span> <span class="n">cons_metric</span> <span class="o">=</span> <span class="n">consonance_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">cons_limit</span><span class="p">)</span>
            <span class="n">extended_temp</span> <span class="o">=</span> <span class="n">multi_consonance</span><span class="p">(</span><span class="n">cons_pairs</span><span class="p">,</span> <span class="n">n_freqs</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">extended_temp</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;consonant_harmonic_fit&quot;</span><span class="p">:</span>
            <span class="n">extended_peaks</span><span class="p">,</span> <span class="n">harmonics</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span>
                <span class="n">peaks</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="p">,</span>
                <span class="n">function</span><span class="o">=</span><span class="n">harm_function</span><span class="p">,</span>
                <span class="n">div_mode</span><span class="o">=</span><span class="n">div_mode</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">harm_bounds</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">consonance</span><span class="p">,</span> <span class="n">cons_pairs</span><span class="p">,</span> <span class="n">cons_peaks</span><span class="p">,</span> <span class="n">cons_metric</span> <span class="o">=</span> <span class="n">consonance_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">cons_limit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">cons_peaks</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;multi_consonant_harmonic_fit&quot;</span><span class="p">:</span>
            <span class="n">extended_peaks</span><span class="p">,</span> <span class="n">harmonics</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span>
                <span class="n">peaks</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="p">,</span>
                <span class="n">function</span><span class="o">=</span><span class="n">harm_function</span><span class="p">,</span>
                <span class="n">div_mode</span><span class="o">=</span><span class="n">div_mode</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">harm_bounds</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">consonance</span><span class="p">,</span> <span class="n">cons_pairs</span><span class="p">,</span> <span class="n">cons_peaks</span><span class="p">,</span> <span class="n">cons_metric</span> <span class="o">=</span> <span class="n">consonance_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">cons_limit</span><span class="p">)</span>
            <span class="n">extended_temp</span> <span class="o">=</span> <span class="n">multi_consonance</span><span class="p">(</span><span class="n">cons_pairs</span><span class="p">,</span> <span class="n">n_freqs</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">extended_temp</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extended_amps</span> <span class="o">=</span> <span class="n">peaks_to_amps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">)</span>
        <span class="c1"># print(&quot;Number of extended peaks : &quot;, len(self.extended_peaks))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ext_peaks_rat</span> <span class="o">=</span> <span class="n">compute_peak_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span><span class="p">,</span> <span class="n">rebound</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ratios_extension</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios_extension</span><span class="p">(</span><span class="n">ext_peaks_rat</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios_harms</span> <span class="o">=</span> <span class="n">a</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios_inc</span> <span class="o">=</span> <span class="n">b</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios_inc_fit</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">ext_peaks_rat</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ext_peaks_rat</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ext_peaks_rat</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios_cons</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">consonant_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span><span class="p">,</span> <span class="n">scale_cons_limit</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_amps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios</span></div>


<div class="viewcode-block" id="compute_biotuner.ratios_extension">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.ratios_extension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ratios_extension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratios</span><span class="p">,</span> <span class="n">ratio_fit_bounds</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">ratios_n_harms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes a series of ratios as input and returns the</span>
<span class="sd">        harmonics (ratio*2, ratio*3, ..., ratio*n) or the increments</span>
<span class="sd">        (ratio**2, ratio**3, ..., ratio**n).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ratios : List (float)</span>
<span class="sd">            List of frequency ratios.</span>
<span class="sd">        ratio_fit_bounds : float, default=0.001</span>
<span class="sd">            Minimal distance between two ratios to consider a fit</span>
<span class="sd">            for the harmonic_fit function.</span>
<span class="sd">        ratios_n_harms : int, default=None</span>
<span class="sd">            Number of harmonics or increments to compute.</span>
<span class="sd">            When None, the number of harmonics or increments</span>
<span class="sd">            is set to the value of the attribute ratios_n_harms.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ratios_harms_ : List (float)</span>
<span class="sd">            List of ratios harmonics.</span>
<span class="sd">        ratios_inc_ : List (float)</span>
<span class="sd">            List of ratios increments.</span>
<span class="sd">        ratios_inc_fit_ : List (float)</span>
<span class="sd">            List of ratios increments that fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ratios_n_harms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ratios_n_harms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios_n_harms</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios_harms</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ratios_harms_</span> <span class="o">=</span> <span class="n">ratios_harmonics</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="n">ratios_n_harms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ratios_harms_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios_inc</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ratios_inc_</span> <span class="o">=</span> <span class="n">ratios_increments</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="n">ratios_n_harms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ratios_inc_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios_inc_fit</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ratios_inc_fit_</span><span class="p">,</span> <span class="n">ratios_inc_fit_pos</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span>
                <span class="n">ratios</span><span class="p">,</span> <span class="n">ratios_n_harms</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">ratio_fit_bounds</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ratios_inc_fit_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">ratios_harms_</span><span class="p">,</span> <span class="n">ratios_inc_</span><span class="p">,</span> <span class="n">ratios_inc_fit_</span></div>


<div class="viewcode-block" id="compute_biotuner.time_resolved_harmonicity">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.time_resolved_harmonicity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_resolved_harmonicity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">input</span><span class="o">=</span><span class="s2">&quot;IF&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
        <span class="n">keep_first_IMF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nIMFs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">IMFs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">limit_cons</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">min_notes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the time-resolved harmonicity of the input data, which involves computation of instantaneous frequency</span>
<span class="sd">        (IF) or SpectroMorph analysis on the input data, followed by harmonicity computation on the IFs or SpectroMorph</span>
<span class="sd">        data.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input : str, default=&#39;IF&#39;</span>
<span class="sd">            The input type for harmonicity computation, either &#39;IF&#39; (instantaneous frequency) or &#39;SpectralCentroid&#39;.</span>
<span class="sd">        method : str, default=&#39;harmsim&#39;</span>
<span class="sd">            The method used for harmonicity computation, such as &#39;harmsim&#39;.</span>
<span class="sd">        keep_first_IMF : bool, default=False</span>
<span class="sd">            Whether to keep the first intrinsic mode function (IMF) after EMD.</span>
<span class="sd">        nIMFs : int, default=3</span>
<span class="sd">            The number of IMFs to consider in the analysis.</span>
<span class="sd">        IMFs : array_like, default=None</span>
<span class="sd">            Precomputed IMFs. If None, IMFs are computed within the method.</span>
<span class="sd">        delta_lim : int, default=20</span>
<span class="sd">            The limit for delta when method is &#39;subharm_tension&#39;.</span>
<span class="sd">        limit_cons : float, default=0.2</span>
<span class="sd">            The limit for consonance for spectral chords.</span>
<span class="sd">        min_notes : int, default=3</span>
<span class="sd">            The minimum number of notes required for spectral chords.</span>
<span class="sd">        graph : bool, default=False</span>
<span class="sd">            If True, a graph of the computed harmonicity will be displayed.</span>
<span class="sd">        window : int, default=None</span>
<span class="sd">            The window size for SpectroMorph analysis. If None, it is set to half of the sampling frequency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing the following:</span>
<span class="sd">            - time_resolved_harmonicity : array_like</span>
<span class="sd">                The time-resolved harmonicity of the input data.</span>
<span class="sd">            - spectro_chords : List of lists (float)</span>
<span class="sd">                Each sublist corresponds to a list of harmonious instantaneous frequencies (IFs).</span>
<span class="sd">            - spectro_chord_pos : List (int)</span>
<span class="sd">                Positions in the time series where each chord from `self.spectro_chords` is located.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.spectro_chords : List of lists (float)</span>
<span class="sd">            Each sublist corresponds to a list of harmonious instantaneous frequencies (IFs).</span>
<span class="sd">        self.time_resolved_harmonicity : array_like</span>
<span class="sd">            The time-resolved harmonicity of the input data.</span>
<span class="sd">        self.spectro_EMD : array_like</span>
<span class="sd">            The spectroMorph analysis of the input data.</span>
<span class="sd">        self.IFs : array_like</span>
<span class="sd">            The instantaneous frequencies of the input data.</span>
<span class="sd">        self.IMFs : array_like</span>
<span class="sd">            The intrinsic mode functions (IMFs) of the input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sf</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">IMFs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">IMFs</span> <span class="o">=</span> <span class="n">EMD_eeg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keep_first_IMF</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="o">==</span> <span class="s2">&quot;IF&quot;</span><span class="p">:</span>
            <span class="n">IMFs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">IMFs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">IP</span><span class="p">,</span> <span class="n">IFs</span><span class="p">,</span> <span class="n">IA</span> <span class="o">=</span> <span class="n">emd</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">frequency_transform</span><span class="p">(</span><span class="n">IMFs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span> <span class="s2">&quot;nht&quot;</span><span class="p">)</span>  <span class="c1"># IFs (time, IMF)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IFs</span> <span class="o">=</span> <span class="n">IFs</span>
            <span class="n">IFs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">IFs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">IFs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="o">==</span> <span class="s2">&quot;SpectralCentroid&quot;</span><span class="p">:</span>
            <span class="n">IFs</span> <span class="o">=</span> <span class="n">EMD_to_spectromorph</span><span class="p">(</span><span class="n">IMFs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SpectralCentroid&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectro_EMD</span> <span class="o">=</span> <span class="n">IFs</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">IFs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectro_chords</span><span class="p">,</span> <span class="n">spectro_chord_pos</span><span class="p">,</span> <span class="n">tr_harm</span> <span class="o">=</span> <span class="n">timepoint_consonance</span><span class="p">(</span>
            <span class="n">IFs</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit_cons</span><span class="p">,</span>
            <span class="n">min_notes</span><span class="o">=</span><span class="n">min_notes</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
            <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectro_chords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">sbn</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">tr_harm</span><span class="p">,</span> <span class="n">dashes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Time Windows&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
                <span class="c1"># if method == &quot;SpectralCentroid&quot;:</span>
                <span class="c1">#    ax.set_yscale(&quot;log&quot;)</span>
                <span class="c1"># plt.legend(</span>
                <span class="c1">#     scatterpoints=1,</span>
                <span class="c1">#     frameon=True,</span>
                <span class="c1">#     labelspacing=1,</span>
                <span class="c1">#     title=&quot;EMDs&quot;,</span>
                <span class="c1">#     loc=&quot;best&quot;,</span>
                <span class="c1">#     labels=[&quot;EMD1&quot;, &quot;EMD2&quot;, &quot;EMD3&quot;, &quot;EMD4&quot;, &quot;EMD5&quot;],</span>
                <span class="c1"># )</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_resolved_harmonicity</span> <span class="o">=</span> <span class="n">tr_harm</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_resolved_harmonicity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectro_chords</span><span class="p">,</span> <span class="n">spectro_chord_pos</span></div>


<div class="viewcode-block" id="compute_biotuner.compute_spectromorph">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.compute_spectromorph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_spectromorph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">IMFs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SpectralCentroid&quot;</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overlap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method computes spectromorphological metrics on</span>
<span class="sd">        each Intrinsic Mode Function (IMF).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IMFs : array (nIMFs, numDataPoints)</span>
<span class="sd">            Intrinsic Mode Functions.</span>
<span class="sd">            When set to &#39;None&#39;, the IMFs are computed in the method.</span>
<span class="sd">        sf : int</span>
<span class="sd">            Sampling frequency.</span>
<span class="sd">        method : str, default=&#39;SpectralCentroid&#39;</span>
<span class="sd">            Spectromorphological metric to compute.</span>

<span class="sd">             - &#39;SpectralCentroid&#39;,</span>
<span class="sd">             - &#39;SpectralCrestFactor&#39;,</span>
<span class="sd">             - &#39;SpectralDecrease&#39;,</span>
<span class="sd">             - &#39;SpectralFlatness&#39;,</span>
<span class="sd">             - &#39;SpectralFlux&#39;,</span>
<span class="sd">             - &#39;SpectralKurtosis&#39;,</span>
<span class="sd">             - &#39;SpectralMfccs&#39;,</span>
<span class="sd">             - &#39;SpectralPitchChroma&#39;,</span>
<span class="sd">             - &#39;SpectralRolloff&#39;,</span>
<span class="sd">             - &#39;SpectralSkewness&#39;,</span>
<span class="sd">             - &#39;SpectralSlope&#39;,</span>
<span class="sd">             - &#39;SpectralSpread&#39;,</span>
<span class="sd">             - &#39;SpectralTonalPowerRatio&#39;,</span>
<span class="sd">             - &#39;TimeAcfCoeff&#39;,</span>
<span class="sd">             - &#39;TimeMaxAcf&#39;,</span>
<span class="sd">             - &#39;TimePeakEnvelope&#39;,</span>
<span class="sd">             - &#39;TimeRms&#39;,</span>
<span class="sd">             - &#39;TimeStd&#39;,</span>
<span class="sd">             - &#39;TimeZeroCrossingRate&#39;,}</span>
<span class="sd">        window : int</span>
<span class="sd">            Window size in samples.</span>
<span class="sd">        overlap : int</span>
<span class="sd">            Value of the overlap between successive windows.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.spectro_EMD : array (numDataPoints, nIMFs)</span>
<span class="sd">            Spectromorphological metric vector for each IMF.</span>
<span class="sd">        self.spectro_chords : List of lists (float)</span>
<span class="sd">            Each sublist corresponds to a list of consonant</span>
<span class="sd">            spectromorphological metrics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">IMFs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">IMFs</span> <span class="o">=</span> <span class="n">EMD_eeg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">)[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">spectro_EMD</span> <span class="o">=</span> <span class="n">EMD_to_spectromorph</span><span class="p">(</span><span class="n">IMFs</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectro_EMD</span> <span class="o">=</span> <span class="n">spectro_EMD</span></div>


<div class="viewcode-block" id="compute_biotuner.compute_peaks_metrics">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.compute_peaks_metrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_peaks_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_harm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">harm_bounds</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes consonance metrics on peaks attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_harm : int</span>
<span class="sd">            Set the number of harmonics to compute in harmonic_fit function</span>
<span class="sd">        harm_bounds : float, default=0.5</span>
<span class="sd">            Maximal distance in Hertz between two frequencies to consider</span>
<span class="sd">            them as equivalent.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.peaks_metrics : dict</span>
<span class="sd">            Dictionary with keys corresponding to the different metrics.</span>

<span class="sd">            - &#39;cons&#39;</span>
<span class="sd">            - &#39;euler&#39;</span>
<span class="sd">            - &#39;tenney&#39;</span>
<span class="sd">            - &#39;harm_fit&#39;</span>
<span class="sd">            - &#39;harmsim&#39;</span>
<span class="sd">            - &#39;n_harmonic_recurrence&#39;,</span>
<span class="sd">            - &#39;n_harmonic_recurrence_ratio&#39;</span>
<span class="sd">            - &#39;harm_pos&#39;</span>
<span class="sd">            - &#39;common_harm_pos&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_harm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_harm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span>

        <span class="n">peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
        <span class="n">peaks_ratios</span> <span class="o">=</span> <span class="n">compute_peak_ratios</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">rebound</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">octave</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_sub_ratios</span><span class="p">)</span>
        <span class="c1"># print(&#39;PEAKS RATIOS COMPUTED&#39;)</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cons&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;euler&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;tenney&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;harm_fit&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="c1"># try:</span>
        <span class="n">harm_fit</span><span class="p">,</span> <span class="n">harm_pos</span><span class="p">,</span> <span class="n">common_harm_pos</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">n_harm</span><span class="o">=</span><span class="n">n_harm</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">harm_bounds</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;harm_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">harm_pos</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;common_harm_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_harm_pos</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">harm_fit</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">harm_fit</span> <span class="o">=</span> <span class="n">harm_fit</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># Convert to a flat list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">harm_fit</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">harm_fit</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Default safeguard</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;harm_fit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">harm_fit</span><span class="p">)</span> <span class="k">if</span> <span class="n">harm_fit</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;cons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">consonance_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># print(&#39;CONSONANCE COMPUTED&#39;)</span>
        <span class="n">peaks_euler</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>

        <span class="n">spf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;if spf == &quot;fixed&quot; or spf == &quot;adapt&quot; or spf == &quot;EMD&quot; or spf == &quot;EEMD&quot;:</span>
<span class="sd">            try:</span>
<span class="sd">                metrics[&quot;euler&quot;] = euler(*peaks_euler)</span>
<span class="sd">            except:</span>
<span class="sd">                pass&quot;&quot;&quot;</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;tenney&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tenneyHeight</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;harmsim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ratios2harmsim</span><span class="p">(</span><span class="n">peaks_ratios</span><span class="p">))</span>
        <span class="c1"># print(&#39;HARMSIM COMPUTED&#39;)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subharm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_subharmonic_tension</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="n">n_harm</span><span class="p">,</span> <span class="n">delta_lim</span><span class="p">,</span> <span class="n">min_notes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;subharm_tension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subharm</span>
        <span class="c1"># print(&#39;SUBHARM COMPUTED&#39;)</span>
        <span class="k">if</span> <span class="n">spf</span> <span class="o">==</span> <span class="s2">&quot;harmonic_recurrence&quot;</span><span class="p">:</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;n_harmonic_recurrence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_harmonic_recurrence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks_metrics</span> <span class="o">=</span> <span class="n">metrics</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods to compute scales from whether peaks or extended peaks&quot;&quot;&quot;</span>

<div class="viewcode-block" id="compute_biotuner.compute_diss_curve">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.compute_diss_curve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_diss_curve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">input_type</span><span class="o">=</span><span class="s2">&quot;peaks&quot;</span><span class="p">,</span>
        <span class="n">denom</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">max_ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">euler_comp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">n_tet_grid</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
        <span class="n">scale_cons_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute dissonance curve based on peak frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_type : str, default=&#39;peaks&#39;</span>
<span class="sd">            Defines whether peaks or extended_peaks are used.</span>

<span class="sd">            - &#39;peaks&#39;</span>
<span class="sd">            - &#39;extended_peaks&#39;</span>

<span class="sd">        denom : int, default=1000</span>
<span class="sd">            Maximal value of the denominator when computing frequency ratios.</span>
<span class="sd">        max_ratio : float, default=2</span>
<span class="sd">            Value of the maximal frequency ratio to use when computing</span>
<span class="sd">            the dissonance curve. When set to 2, the curve spans one octave.</span>
<span class="sd">            When set to 4, the curve spans two octaves.</span>
<span class="sd">        euler_comp : Boolean, default=False</span>
<span class="sd">            Defines if euler consonance is computed. Can be computationally</span>
<span class="sd">            expensive when the number of local minima is high.</span>
<span class="sd">        method : str, default=&#39;min&#39;</span>
<span class="sd">            Refer to dissmeasure function in scale_construction.py</span>
<span class="sd">            for more information.</span>

<span class="sd">            - &#39;min&#39;</span>
<span class="sd">            - &#39;product&#39;</span>

<span class="sd">        plot : Boolean, default=False</span>
<span class="sd">            When set to True, dissonance curve is plotted.</span>
<span class="sd">        n_tet_grid : int, default=12</span>
<span class="sd">            Defines which N-TET tuning is indicated, as a reference,</span>
<span class="sd">            in red in the dissonance curve plot.</span>
<span class="sd">        scale_cons_limit : float, default=None</span>
<span class="sd">            Minimal value of consonance to be reach for a peaks ratio</span>
<span class="sd">            to be included in the self.diss_scale_cons attribute.</span>
<span class="sd">            When set to None, the value of self.scale_cons_limit is used.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.diss_scale : List (float)</span>
<span class="sd">            List of frequency ratios corresponding to local minima.</span>
<span class="sd">        self.diss_scale_cons : List (float)</span>
<span class="sd">            List of frequency ratios corresponding to consonant local minima.</span>
<span class="sd">        self.scale_metrics : dict</span>
<span class="sd">            Add 4 metrics related to the dissonance curve tuning:</span>

<span class="sd">            - &#39;diss_euler&#39;</span>
<span class="sd">            - &#39;dissonance&#39;</span>
<span class="sd">            - &#39;diss_harm_sim&#39;</span>
<span class="sd">            - &#39;diss_n_steps&#39;</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;peaks&quot;</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amps</span>
            <span class="c1"># TODO : check if self.amps exists</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;extended_peaks&quot;</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_amps</span>
        <span class="k">if</span> <span class="n">scale_cons_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_cons_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_cons_limit</span>

        <span class="n">peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="mi">128</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>  <span class="c1"># scale the peaks up to accomodate beating frequency modelling.</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amps</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amps</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">))</span>

        <span class="n">diss</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diss_scale</span><span class="p">,</span> <span class="n">euler_diss</span><span class="p">,</span> <span class="n">diss_avg</span><span class="p">,</span> <span class="n">harm_sim_diss</span> <span class="o">=</span> <span class="n">diss_curve</span><span class="p">(</span>
            <span class="n">peaks</span><span class="p">,</span>
            <span class="n">amps</span><span class="p">,</span>
            <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">,</span>
            <span class="n">max_ratio</span><span class="o">=</span><span class="n">max_ratio</span><span class="p">,</span>
            <span class="n">euler_comp</span><span class="o">=</span><span class="n">euler_comp</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
            <span class="n">n_tet_grid</span><span class="o">=</span><span class="n">n_tet_grid</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diss_scale_cons</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">consonant_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diss_scale</span><span class="p">,</span> <span class="n">scale_cons_limit</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">input_type</span><span class="o">=</span><span class="s2">&quot;ratios&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span><span class="p">[</span><span class="s2">&quot;diss_euler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler_diss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span><span class="p">[</span><span class="s2">&quot;dissonance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">diss_avg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span><span class="p">[</span><span class="s2">&quot;diss_harm_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">harm_sim_diss</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span><span class="p">[</span><span class="s2">&quot;diss_n_steps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diss_scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_biotuner.compute_harmonic_entropy">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.compute_harmonic_entropy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_harmonic_entropy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">input_type</span><span class="o">=</span><span class="s2">&quot;peaks&quot;</span><span class="p">,</span>
        <span class="n">res</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">spread</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">plot_entropy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot_tenney</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">octave</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">rebound</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">sub</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scale_cons_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the harmonic entropy from a series of spectral peaks.</span>
<span class="sd">        Harmonic entropy has been introduced by Paul Elrich</span>
<span class="sd">        [http://www.tonalsoft.com/enc/e/erlich/harmonic-entropy_with-</span>
<span class="sd">        commentary.aspx]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_type : str, default=&#39;peaks&#39;</span>
<span class="sd">            Defines whether peaks or extended_peaks are used.</span>

<span class="sd">            - &#39;peaks&#39;</span>
<span class="sd">            - &#39;extended_peaks&#39;</span>

<span class="sd">        res : float, default=0.001</span>
<span class="sd">            Resolution of the ratio steps.</span>
<span class="sd">        spread : float, default=0.01</span>
<span class="sd">            Spread of the normal distribution used to compute the weights.</span>
<span class="sd">        plot_entropy : Boolean, default=True</span>
<span class="sd">            When set to True, plot the harmonic entropy curve.</span>
<span class="sd">        plot_tenney : Boolean, default=False</span>
<span class="sd">            When set to True, plot the tenney heights (y-axis)</span>
<span class="sd">            across ratios (x-axis).</span>
<span class="sd">        octave : int, default=2</span>
<span class="sd">            Value of the octave.</span>
<span class="sd">        rebound : Boolean, default=True</span>
<span class="sd">            When set to True, peaks ratios are bounded within the octave.</span>
<span class="sd">        sub : Boolean, default=False</span>
<span class="sd">            When set to True, will include ratios below the unison (1)</span>
<span class="sd">        scale_cons_limit : type, default=None</span>
<span class="sd">            Minimal value of consonance to be reach for a peaks ratio</span>
<span class="sd">            to be included in the self.diss_scale_cons attribute.</span>
<span class="sd">            When set to None, the value of self.scale_cons_limit is used.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.HE_scale : List (float)</span>
<span class="sd">            List of frequency ratios corresponding to local minima.</span>
<span class="sd">        self.HE_scale_cons : List (float)</span>
<span class="sd">            List of frequency ratios corresponding to consonant local minima.</span>
<span class="sd">        self.scale_metrics : dict</span>
<span class="sd">            Four metrics related to the dissonance curve tuning:</span>

<span class="sd">            - &#39;HE&#39;</span>
<span class="sd">            - &#39;HE_n_steps&#39;</span>
<span class="sd">            - &#39;HE_harm_sim&#39;</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;peaks&quot;</span><span class="p">:</span>
            <span class="n">ratios</span> <span class="o">=</span> <span class="n">compute_peak_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">,</span> <span class="n">rebound</span><span class="o">=</span><span class="n">rebound</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="n">sub</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;extended_peaks&quot;</span><span class="p">:</span>
            <span class="n">ratios</span> <span class="o">=</span> <span class="n">compute_peak_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span><span class="p">,</span> <span class="n">rebound</span><span class="o">=</span><span class="n">rebound</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="n">sub</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;extended_ratios_harms&quot;</span><span class="p">:</span>
            <span class="n">ratios</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios_harms</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;extended_ratios_inc&quot;</span><span class="p">:</span>
            <span class="n">ratios</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios_inc</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;extended_ratios_inc_fit&quot;</span><span class="p">:</span>
            <span class="n">ratios</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios_inc_fit</span>
        <span class="k">if</span> <span class="n">scale_cons_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_cons_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_cons_limit</span>

        <span class="n">HE_scale</span><span class="p">,</span> <span class="n">HE</span><span class="p">,</span> <span class="n">HE_all</span> <span class="o">=</span> <span class="n">harmonic_entropy</span><span class="p">(</span>
            <span class="n">ratios</span><span class="p">,</span>
            <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span>
            <span class="n">spread</span><span class="o">=</span><span class="n">spread</span><span class="p">,</span>
            <span class="n">plot_entropy</span><span class="o">=</span><span class="n">plot_entropy</span><span class="p">,</span>
            <span class="n">plot_tenney</span><span class="o">=</span><span class="n">plot_tenney</span><span class="p">,</span>
            <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HE_scale</span> <span class="o">=</span> <span class="n">HE_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HE_scale_cons</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">consonant_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HE_scale</span><span class="p">,</span> <span class="n">scale_cons_limit</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">input_type</span><span class="o">=</span><span class="s2">&quot;ratios&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span><span class="p">[</span><span class="s2">&quot;HE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span><span class="p">[</span><span class="s2">&quot;HE_n_steps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HE_scale</span><span class="p">)</span>
        <span class="n">HE_harm_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ratios2harmsim</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HE_scale</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_metrics</span><span class="p">[</span><span class="s2">&quot;HE_harm_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HE_harm_sim</span></div>


<div class="viewcode-block" id="compute_biotuner.euler_fokker_scale">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.euler_fokker_scale">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">euler_fokker_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;peaks&quot;</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a scale in the Euler-Fokker Genera. which is a</span>
<span class="sd">        musical scale in just intonation whose pitches can be</span>
<span class="sd">        expressed as products of some of the members of some multiset</span>
<span class="sd">        of generating primer numbers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, default=&#39;peaks&#39;</span>
<span class="sd">            Defines which set of frequencies are used.</span>

<span class="sd">            - &#39;peaks&#39;</span>
<span class="sd">            - &#39;extended_peaks&#39;</span>

<span class="sd">        octave : float, default=2</span>
<span class="sd">            Value of period interval.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.euler_fokker : List (float)</span>
<span class="sd">            Euler-Fokker genera.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.euler_fokker : List (float)</span>
<span class="sd">            Euler-Fokker genera.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;peaks&quot;</span><span class="p">:</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;extended_peaks&quot;</span><span class="p">:</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="n">prime_factor</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">])</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">euler_fokker_scale</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="n">octave</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euler_fokker</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">return</span> <span class="n">scale</span></div>


<div class="viewcode-block" id="compute_biotuner.harmonic_tuning">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.harmonic_tuning">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">harmonic_tuning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_harmonics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">octave</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a tuning based on a list of harmonic positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        list_harmonics: List of int</span>
<span class="sd">            harmonic positions to use in the scale construction</span>
<span class="sd">        octave: int, default=2</span>
<span class="sd">            value of the period reference</span>
<span class="sd">        min_ratio: float, default=1</span>
<span class="sd">            Value of the unison.</span>
<span class="sd">        max_ratio: float, default=2</span>
<span class="sd">            Value of the octave.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ratios : List (float)</span>
<span class="sd">            Generated tuning.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.harmonic_tuning : List (float)</span>
<span class="sd">            Generated tuning.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">list_harmonics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_function</span> <span class="o">==</span> <span class="s2">&quot;harmonic_recurrence&quot;</span><span class="p">:</span>
                <span class="n">list_harmonics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harmonics</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No list of harmonics provided&quot;</span><span class="p">)</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_harmonics</span><span class="p">:</span>
            <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rebound</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">min_ratio</span><span class="p">,</span> <span class="n">max_ratio</span><span class="p">,</span> <span class="n">octave</span><span class="p">))</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ratios</span><span class="p">))</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratios</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_tuning</span> <span class="o">=</span> <span class="n">ratios</span>
        <span class="k">return</span> <span class="n">ratios</span></div>


<div class="viewcode-block" id="compute_biotuner.harmonic_fit_tuning">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.harmonic_fit_tuning">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">harmonic_fit_tuning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_harm</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">n_common_harms</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the common harmonics of spectral peaks and compute</span>
<span class="sd">        the associated harmonic tuning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_harm : int</span>
<span class="sd">            Number of harmonics to consider in the harmonic fit`.</span>
<span class="sd">        bounds : float, default=0.1</span>
<span class="sd">            Maximal distance in Hertz between two frequencies to consider</span>
<span class="sd">            them as equivalent.</span>
<span class="sd">        n_common_harms : int, default=2</span>
<span class="sd">            minimum number of times the harmonic is found</span>
<span class="sd">            to be sent to most_common_harmonics output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.harmonic_fit_tuning : List (float)</span>
<span class="sd">            Generated tuning</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.harmonic_fit_tuning : List (float)</span>
<span class="sd">            Generated tuning</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">harmonics</span><span class="p">,</span> <span class="n">common_h</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">,</span> <span class="n">n_harm</span><span class="o">=</span><span class="n">n_harm</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">n_common_harms</span><span class="o">=</span><span class="n">n_common_harms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_fit_tuning</span> <span class="o">=</span> <span class="n">harmonic_tuning</span><span class="p">(</span><span class="n">common_h</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_fit_tuning</span></div>


<div class="viewcode-block" id="compute_biotuner.pac">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.pac">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pac</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;duprelatour&quot;</span><span class="p">,</span>
        <span class="n">n_values</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">drive_precision</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">max_drive_freq</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="n">min_drive_freq</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">sig_precision</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_sig_freq</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">min_sig_freq</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
        <span class="n">low_fq_width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">high_fq_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the phase-amplitude coupling and returns to pairs of</span>
<span class="sd">        frequencies that have highest coupling value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sf : int</span>
<span class="sd">            Sampling frequency in hertz.</span>
<span class="sd">        method : str, default=&#39;duprelatour&#39;</span>
<span class="sd">            Choice of method for PAC calculation.</span>
<span class="sd">                STANDARD_PAC_METRICS:</span>

<span class="sd">                    - &#39;ozkurt&#39;</span>
<span class="sd">                    - &#39;canolty&#39;</span>
<span class="sd">                    - &#39;tort&#39;</span>
<span class="sd">                    - &#39;penny&#39;</span>
<span class="sd">                    - &#39;vanwijk&#39;</span>

<span class="sd">                DAR_BASED_PAC_METRICS:</span>

<span class="sd">                    - &#39;duprelatour&#39;</span>

<span class="sd">                COHERENCE_PAC_METRICS:</span>

<span class="sd">                    - &#39;jiang&#39;</span>
<span class="sd">                    - &#39;colgin&#39;</span>

<span class="sd">                BICOHERENCE_PAC_METRICS:</span>

<span class="sd">                    - &#39;sigl&#39;</span>
<span class="sd">                    - &#39;nagashima&#39;</span>
<span class="sd">                    - &#39;hagihira&#39;</span>
<span class="sd">                    - &#39;bispectrum&#39;</span>

<span class="sd">        n_values : int, default=10</span>
<span class="sd">            Number of pairs of frequencies to return.</span>
<span class="sd">        drive_precision : float, default=0.05</span>
<span class="sd">            Step-size between each phase signal bins.</span>
<span class="sd">        max_drive_freq : float, default=6</span>
<span class="sd">            Maximum value of the phase signal in hertz.</span>
<span class="sd">        min_drive_freq : float, default=3</span>
<span class="sd">            Minimum value of the phase signal in hertz.</span>
<span class="sd">        sig_precision : float, default=1</span>
<span class="sd">            Step-size between each amplitude signal bins.</span>
<span class="sd">        max_sig_freq : float, default=50</span>
<span class="sd">            Maximum value of the amplitude signal in hertz.</span>
<span class="sd">        min_sig_freq : float, default=8</span>
<span class="sd">            Minimum value of the amplitude signal in hertz.</span>
<span class="sd">        low_fq_width : float, default=0.5</span>
<span class="sd">            Bandwidth of the band-pass filter (phase signal)</span>
<span class="sd">        high_fq_width : float, default=1</span>
<span class="sd">            Bandwidth of the band-pass filter (amplitude signal)</span>
<span class="sd">        plot : Boolean, default=False</span>
<span class="sd">            When set to True, a plot of the comodulogram is generated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pac_freqs : List of lists (float)</span>
<span class="sd">            Pairs of frequencies with highest coupling value. Stored in self.pac_freqs.</span>
<span class="sd">        pac_coupling : List (float)</span>
<span class="sd">            Values of coupling for each pair in pac_freqs. Stored in self.pac_coupling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">pac_coupling</span> <span class="o">=</span> <span class="n">pac_frequencies</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">sf</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">n_values</span><span class="o">=</span><span class="n">n_values</span><span class="p">,</span>
            <span class="n">drive_precision</span><span class="o">=</span><span class="n">drive_precision</span><span class="p">,</span>
            <span class="n">max_drive_freq</span><span class="o">=</span><span class="n">max_drive_freq</span><span class="p">,</span>
            <span class="n">min_drive_freq</span><span class="o">=</span><span class="n">min_drive_freq</span><span class="p">,</span>
            <span class="n">sig_precision</span><span class="o">=</span><span class="n">sig_precision</span><span class="p">,</span>
            <span class="n">max_sig_freq</span><span class="o">=</span><span class="n">max_sig_freq</span><span class="p">,</span>
            <span class="n">min_sig_freq</span><span class="o">=</span><span class="n">min_sig_freq</span><span class="p">,</span>
            <span class="n">low_fq_width</span><span class="o">=</span><span class="n">low_fq_width</span><span class="p">,</span>
            <span class="n">high_fq_width</span><span class="o">=</span><span class="n">high_fq_width</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pac_freqs</span> <span class="o">=</span> <span class="n">freqs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pac_coupling</span> <span class="o">=</span> <span class="n">pac_coupling</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pac_freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pac_coupling</span></div>


<div class="viewcode-block" id="compute_biotuner.rhythm_construction">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.rhythm_construction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rhythm_construction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;peaks_ratios&quot;</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
        <span class="n">cons_threshold</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">max_denom</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
        <span class="n">n_steps_down</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">optimal_offsets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Euclidean rhythms from a scale defined between unison and octave.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : str, default=&#39;peaks_ratios&#39;</span>
<span class="sd">            The scale from which Euclidean rhythms are generated. Options include &#39;peaks_ratios&#39;, &#39;extended_peaks_ratios&#39;,</span>
<span class="sd">            &#39;diss_scale&#39;, &#39;HE_scale&#39;, &#39;harmonic_fit_tuning&#39;, &#39;harmonic_tuning&#39;, and &#39;euler_fokker&#39;, each corresponding to</span>
<span class="sd">            a different scale computation method within the class.</span>
<span class="sd">        mode : str, default=&#39;default&#39;</span>
<span class="sd">            The rhythm generation mode. Options are &#39;default&#39; for basic Euclidean rhythms and &#39;consonant&#39; for rhythms with</span>
<span class="sd">            maximized consonance, based on the &#39;cons_threshold&#39; parameter and the use of shared denominator values.</span>
<span class="sd">        cons_threshold : float, default=0.2</span>
<span class="sd">            Consonance threshold used in &#39;consonant&#39; mode to maximize consonance between rhythm pairs.</span>
<span class="sd">            See the &#39;compute_consonance&#39; function in the &#39;scale_construction&#39; module for more information.</span>
<span class="sd">        max_denom : int, default=8</span>
<span class="sd">            The maximum denominator used in the rhythm generation process, controlling the complexity of the rhythm.</span>
<span class="sd">            Only used in &#39;consonant&#39; mode.</span>
<span class="sd">        n_steps_down : int, default=3</span>
<span class="sd">            The number of steps by which the generated Euclidean rhythm is transposed down.</span>
<span class="sd">            Only used in &#39;consonant&#39; mode.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the specified &#39;scale&#39; is not computed prior to invoking this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The first element is a list of generated Euclidean rhythms. The second element is their corresponding referential strings, derived from comparing the generated rhythms to known referent patterns.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method requires the prior computation of the specified &#39;scale&#39;. For instance, &#39;peaks_ratios&#39; requires the &#39;peaks_extraction&#39; method to be called beforehand. The method&#39;s return values are integral to further rhythm analysis and comparison within the Biot</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;peaks_ratios&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios</span>
            <span class="c1"># raise error if peaks_ratios is not computed</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;peaks_ratios not computed. Call the peaks_extraction method first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;extended_peaks_ratios&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios</span>
            <span class="c1"># raise error if extended_peaks_ratios is not computed</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;extended_peaks_ratios not computed. Calling the peaks_extension method first.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peaks_extension</span><span class="p">()</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_peaks_ratios</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;diss_scale&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diss_scale</span>
            <span class="c1"># raise error if diss_scale is not computed</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;diss_scale not computed. Call the compute_diss_curve method first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;HE_scale&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HE_scale</span>
            <span class="c1"># raise error if HE_scale is not computed</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;HE_scale not computed. Call the compute_harmonic_entropy method first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;harmonic_fit_tuning&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_fit_tuning</span>
            <span class="c1"># raise error if harmonic_fit_tuning is not computed</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;harmonic_fit_tuning not computed. Call the harmonic_fit_tuning method first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;harmonic_tuning&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_tuning</span>
            <span class="c1"># raise error if harmonic_tuning is not computed</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;harmonic_tuning not computed. Call the harmonic_tuning method first and ensure that the peaks_extraction method was called with harmonic_recurrence as peaks_function.&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;euler_fokker&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_fokker</span>
            <span class="c1"># raise error if euler_fokker is not computed</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;euler_fokker not computed. Call the euler_fokker_scale method first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">euclid_final</span> <span class="o">=</span> <span class="n">scale2euclid</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">max_denom</span><span class="o">=</span><span class="n">max_denom</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;consonant&quot;</span><span class="p">:</span>
            <span class="n">euclid_final</span><span class="p">,</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">consonant_euclid</span><span class="p">(</span>
                <span class="n">scale</span><span class="p">,</span>
                <span class="n">n_steps_down</span><span class="o">=</span><span class="n">n_steps_down</span><span class="p">,</span>
                <span class="n">limit_denom</span><span class="o">=</span><span class="n">max_denom</span><span class="p">,</span>
                <span class="n">limit_cons</span><span class="o">=</span><span class="n">cons_threshold</span><span class="p">,</span>
                <span class="n">limit_denom_final</span><span class="o">=</span><span class="n">max_denom</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Compare rhythms to referents</span>
        <span class="n">interval_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">interval_vector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">euclid_final</span><span class="p">]</span>
        <span class="n">strings</span> <span class="o">=</span> <span class="n">interval_vec_to_string</span><span class="p">(</span><span class="n">interval_vectors</span><span class="p">)</span>
        <span class="n">euclid_referent</span> <span class="o">=</span> <span class="n">euclid_string_to_referent</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="n">dict_rhythms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euclid_rhythms</span> <span class="o">=</span> <span class="n">euclid_final</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">euclid_referent</span> <span class="o">=</span> <span class="n">euclid_referent</span>
        <span class="n">euclid_rhythms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">euclid_final</span><span class="p">[:])):</span>
            <span class="n">pulse</span> <span class="o">=</span> <span class="n">euclid_final</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">euclid_final</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">euclid_rhythms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pulse</span><span class="p">,</span> <span class="n">steps</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">optimal_offsets</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">find_optimal_offsets</span><span class="p">(</span><span class="n">euclid_rhythms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.05</span>
            <span class="n">visualize_rhythms</span><span class="p">(</span><span class="n">euclid_rhythms</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;plasma_r&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">euclid_final</span><span class="p">,</span> <span class="n">euclid_rhythms</span><span class="p">,</span> <span class="n">euclid_referent</span></div>


<div class="viewcode-block" id="compute_biotuner.compute_peaks_ts">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.compute_peaks_ts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_peaks_ts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">peaks_function</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">,</span>
        <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
        <span class="n">min_harms</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">harm_limit</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
        <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">prominence</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">rel_height</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
        <span class="n">nIMFs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">average</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
        <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_harm_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">EIMC_order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">min_IMs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">smooth_fft</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">keep_first_IMF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract peak frequencies. This method is called by the</span>
<span class="sd">        peaks_extraction method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: array (numDataPoints,)</span>
<span class="sd">            Niosignal to analyse</span>
<span class="sd">        peaks_function: str</span>
<span class="sd">            Refer to __init__</span>
<span class="sd">        FREQ_BANDS: List of lists of floats</span>
<span class="sd">            Each list within the list of lists sets the lower and</span>
<span class="sd">            upper limit of a frequency band</span>
<span class="sd">        precision: float, default=0.5</span>
<span class="sd">            Precision of the peaks (in Hz)</span>
<span class="sd">            When HH1D_max is used, bins are in log scale.</span>
<span class="sd">        sf : int, default=None</span>
<span class="sd">            Sampling frequency in hertz.</span>
<span class="sd">        min_freq: float, default=1</span>
<span class="sd">            Minimum frequency value to be considered as a peak</span>
<span class="sd">            Used with &#39;harmonic_recurrence&#39; and &#39;HH1D_max&#39; peaks functions</span>
<span class="sd">        max_freq: float, default=80</span>
<span class="sd">            Maximum frequency value to be considered as a peak</span>
<span class="sd">            Used with &#39;harmonic_recurrence&#39; and &#39;HH1D_max&#39; peaks functions</span>
<span class="sd">        min_harms : int, default=2</span>
<span class="sd">            Minimum number of harmonics to be considered for peaks extraction</span>
<span class="sd">        harm_limit: int, default=128</span>
<span class="sd">            Maximum harmonic position for &#39;harmonic_recurrence&#39; method.</span>
<span class="sd">        n_peaks: int, default=5</span>
<span class="sd">            Number of peaks when using &#39;FOOOF&#39; and &#39;cepstrum&#39;,</span>
<span class="sd">            and &#39;harmonic_recurrence&#39; functions.</span>
<span class="sd">            Peaks are chosen based on their amplitude.</span>
<span class="sd">        prominence: float, default=1.0</span>
<span class="sd">            Minimum prominence value to be considered as a peak</span>
<span class="sd">            Used with &#39;harmonic_recurrence&#39; and &#39;HH1D_max&#39; peaks functions</span>
<span class="sd">        rel_height: float, default=0.7</span>
<span class="sd">            Minimum relative height value to be considered as a peak</span>
<span class="sd">        nIMFs: int, default=None</span>
<span class="sd">            number of intrinsic mode functions to keep when using</span>
<span class="sd">            &#39;EEMD&#39; or &#39;EMD&#39; peaks function.</span>
<span class="sd">        graph: boolean, default=False</span>
<span class="sd">            When set to True, a graph will accompanies the peak extraction</span>
<span class="sd">            method (except for &#39;fixed&#39; and &#39;adapt&#39;).</span>
<span class="sd">        noverlap : int, default=None</span>
<span class="sd">            Number of samples overlap between each fft window.</span>
<span class="sd">            When set to None, equals sf//10.</span>
<span class="sd">        average : str, default=&#39;median&#39;</span>
<span class="sd">            Method to use when averaging periodograms.</span>

<span class="sd">            - &#39;mean&#39;: average periodograms</span>
<span class="sd">            - &#39;median&#39;: median periodograms</span>

<span class="sd">        max_harm_freq : int, default=None</span>
<span class="sd">            Maximum frequency value of the find peaks function</span>
<span class="sd">            when harmonic_recurrence or EIMC peaks extraction method is used.</span>
<span class="sd">        EIMC_order : int, default=3</span>
<span class="sd">            Maximum order of the Intermodulation Components.</span>
<span class="sd">        min_IMs : int, default=2</span>
<span class="sd">            Minimal number of Intermodulation Components to select the</span>
<span class="sd">            associated pair of peaks.</span>
<span class="sd">        smooth_fft : int, default=1</span>
<span class="sd">            Number used to divide nfft to derive nperseg.</span>
<span class="sd">            When set to 1, nperseg = nfft.</span>
<span class="sd">        keep_first_IMF : boolean, default=False</span>
<span class="sd">            When set to True, the first IMF is kept.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        peaks : List (float)</span>
<span class="sd">            List of peaks frequencies.</span>
<span class="sd">        amps : List (float)</span>
<span class="sd">            List of amplitudes associated with peaks frequencies.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.freqs : array</span>
<span class="sd">            Vector representing the frequency bins of</span>
<span class="sd">            the Power Spectrum Density (PSD)</span>
<span class="sd">        self.psd : array</span>
<span class="sd">            Vector representing the PSD values for each frequency bin.</span>
<span class="sd">        self.IMFs : array (nIMFs, numDataPoints)</span>
<span class="sd">            Intrinsic mode functions resulting from decomposing the signal</span>
<span class="sd">            with Empirical Mode Decomposition.</span>
<span class="sd">        self.IF : array (nIMFs, numDataPoints)</span>
<span class="sd">            instantaneous frequencies for each IMF.</span>
<span class="sd">            Only when &#39;HH1D_max&#39; is used as peaks extraction method.</span>
<span class="sd">        self.all_harmonics : List (int)</span>
<span class="sd">            List of all harmonic positions when</span>
<span class="sd">            harmonic_recurrence method is used.</span>
<span class="sd">        self.FREQ_BANDS : List of lists (float)</span>
<span class="sd">            List of frequency bands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alphaband</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="k">if</span> <span class="n">nIMFs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nIMFs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nIMFs</span>
        <span class="k">if</span> <span class="n">FREQ_BANDS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FREQ_BANDS</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3.55</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">3.55</span><span class="p">,</span> <span class="mf">7.15</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">7.15</span><span class="p">,</span> <span class="mf">14.3</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">14.3</span><span class="p">,</span> <span class="mf">28.55</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">28.55</span><span class="p">,</span> <span class="mf">49.4</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">FREQ_BANDS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FREQ_BANDS</span> <span class="o">=</span> <span class="n">FREQ_BANDS</span>
        <span class="k">if</span> <span class="n">max_harm_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_harm_freq</span> <span class="o">=</span> <span class="n">sf</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FREQ_BANDS</span> <span class="o">=</span> <span class="n">FREQ_BANDS</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;adapt&quot;</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">extract_welch_peaks</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">alphaband</span><span class="p">,</span>
                <span class="n">out_type</span><span class="o">=</span><span class="s2">&quot;bands&quot;</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
                <span class="n">extended_returns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
                <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span>
                <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">FREQ_BANDS</span> <span class="o">=</span> <span class="n">alpha2bands</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FREQ_BANDS</span> <span class="o">=</span> <span class="n">FREQ_BANDS</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adaptive frequency bands: &quot;</span><span class="p">,</span> <span class="n">FREQ_BANDS</span><span class="p">)</span>
            <span class="n">peaks_temp</span><span class="p">,</span> <span class="n">amps_temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">extract_welch_peaks</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
                <span class="n">out_type</span><span class="o">=</span><span class="s2">&quot;bands&quot;</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
                <span class="n">extended_returns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">graph_psd_peaks</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span>
                    <span class="n">peaks_temp</span><span class="p">,</span>
                    <span class="n">xmin</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                    <span class="n">xmax</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkblue&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
            <span class="n">peaks_temp</span><span class="p">,</span> <span class="n">amps_temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">extract_welch_peaks</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
                <span class="n">out_type</span><span class="o">=</span><span class="s2">&quot;bands&quot;</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
                <span class="n">extended_returns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
                <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span>
                <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">graph_psd_peaks</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span>
                    <span class="n">peaks_temp</span><span class="p">,</span>
                    <span class="n">xmin</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                    <span class="n">xmax</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkred&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;FOOOF&quot;</span><span class="p">:</span>
            <span class="n">peaks_temp</span><span class="p">,</span> <span class="n">amps_temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">compute_FOOOF</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">n_peaks</span><span class="o">=</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">extended_returns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;EMD&quot;</span>
            <span class="ow">or</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;EEMD&quot;</span>
            <span class="ow">or</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;CEEMDAN&quot;</span>
            <span class="c1"># or peaks_function == &quot;EMD_fast&quot;</span>
            <span class="c1"># or peaks_function == &quot;EEMD_fast&quot;</span>
        <span class="p">):</span>
            <span class="n">IMFs</span> <span class="o">=</span> <span class="n">EMD_eeg</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">extrema_detection</span><span class="o">=</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span>
                <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">keep_first_IMF</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">keep_first_IMF</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># try:</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">freqs_all</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">psd_all</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">imf</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IMFs</span><span class="p">)):</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">extract_welch_peaks</span><span class="p">(</span>
                    <span class="n">IMFs</span><span class="p">[</span><span class="n">imf</span><span class="p">],</span>
                    <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
                    <span class="n">extended_returns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">out_type</span><span class="o">=</span><span class="s2">&quot;single&quot;</span><span class="p">,</span>
                    <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                    <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                    <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
                    <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span>
                    <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># self.freqs = freqs</span>
                <span class="n">freqs_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
                <span class="n">psd_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
                <span class="n">peaks_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">amps_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">peaks_temp</span><span class="p">)</span>
            <span class="c1"># print(&#39;PEAKS_TEMP&#39;, peaks_temp, &#39;AMPS_TEMP&#39;, amps_temp)</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">amps_temp</span><span class="p">)</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="n">peaks_temp</span><span class="p">[</span><span class="o">-</span><span class="n">n_peaks</span><span class="p">:]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">extract_welch_peaks</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
                <span class="n">out_type</span><span class="o">=</span><span class="s2">&quot;single&quot;</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
                <span class="n">extended_returns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
                <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span>
                <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># except:</span>
            <span class="c1">#    pass</span>
            <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;graphEMD_welch(</span>
<span class="sd">                    freqs_all,</span>
<span class="sd">                    psd_all,</span>
<span class="sd">                    peaks=peaks_temp,</span>
<span class="sd">                    raw_data=self.data,</span>
<span class="sd">                    FREQ_BANDS=FREQ_BANDS,</span>
<span class="sd">                    sf=sf,</span>
<span class="sd">                    nfft=nfft,</span>
<span class="sd">                    nperseg=nperseg,</span>
<span class="sd">                    noverlap=noverlap,</span>
<span class="sd">                    min_freq=min_freq,</span>
<span class="sd">                    max_freq=max_freq,</span>
<span class="sd">                )&quot;&quot;&quot;</span>
                <span class="n">graphEMD_welch</span><span class="p">(</span>
                    <span class="n">freqs_all</span><span class="p">,</span>
                    <span class="n">psd_all</span><span class="p">,</span>
                    <span class="n">peaks_temp</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">FREQ_BANDS</span><span class="p">,</span>
                    <span class="n">sf</span><span class="p">,</span>
                    <span class="n">nfft</span><span class="p">,</span>
                    <span class="n">nperseg</span><span class="p">,</span>
                    <span class="n">noverlap</span><span class="p">,</span>
                    <span class="n">min_freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">max_freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
                    <span class="n">precision</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># (self.data, self.IMFs, peaks_temp, spectro=&#39;Euler&#39;, bands = None, xmin=min_freq, xmax=max_freq,</span>
                <span class="c1">#                  compare = True, name = &#39;&#39;, nfft=nfft, nperseg=nperseg, noverlap=noverlap, sf=self.sf,</span>
                <span class="c1">#                  freqs_all=freqs_all, psd_all=psd_all, max_freq=max_freq, precision=precision)</span>
                <span class="c1"># EMD_PSD_graph(peaks_temp, IMFs, freqs_all, psd_all, spectro=&#39;Euler&#39;, bands=None, xmin=1, xmax=70, plot_type = &#39;line&#39;,</span>
                <span class="c1">#              compare=True, input_data=&#39;EEG&#39;, name=&#39;&#39;,sf=self.sf,</span>
                <span class="c1">#              raw_data=self.data, precision=precision, noverlap=noverlap, save=False)</span>

        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;EMD_FOOOF&quot;</span><span class="p">:</span>
            <span class="n">nfft</span> <span class="o">=</span> <span class="n">sf</span> <span class="o">/</span> <span class="n">precision</span>
            <span class="n">nperseg</span> <span class="o">=</span> <span class="n">sf</span> <span class="o">/</span> <span class="n">precision</span>
            <span class="n">IMFs</span> <span class="o">=</span> <span class="n">EMD_eeg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">extrema_detection</span><span class="o">=</span><span class="s2">&quot;simple&quot;</span><span class="p">)[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IMFs</span> <span class="o">=</span> <span class="n">IMFs</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">imf</span> <span class="ow">in</span> <span class="n">IMFs</span><span class="p">:</span>
                <span class="n">freqs1</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">imf</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span>
                <span class="n">fm</span> <span class="o">=</span> <span class="n">FOOOF</span><span class="p">(</span>
                    <span class="n">peak_width_limits</span><span class="o">=</span><span class="p">[</span><span class="n">precision</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                    <span class="n">max_n_peaks</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                    <span class="n">min_peak_height</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">freq_range</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sf</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">]</span>
                <span class="n">fm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">freqs1</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">freq_range</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">fm</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">freqs1</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">freq_range</span><span class="p">)</span>
                <span class="n">peaks_temp_EMD</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">peak_params_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">amps_temp_EMD</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">peak_params_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Select the peak with highest amplitude.</span>
                    <span class="n">peaks_temp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">amps_temp_EMD</span><span class="p">,</span> <span class="n">peaks_temp_EMD</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">amps_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">amps_temp_EMD</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No peaks detected&quot;</span><span class="p">)</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks_temp</span><span class="p">]</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">peaks_temp</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">amps_temp</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;HH1D_max&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smooth_fft</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">smooth_sigma</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">smooth_sigma</span> <span class="o">=</span> <span class="n">smooth_fft</span>
            <span class="n">IF</span><span class="p">,</span> <span class="n">peaks_temp</span><span class="p">,</span> <span class="n">amps_temp</span><span class="p">,</span> <span class="n">HH_spec</span><span class="p">,</span> <span class="n">HH_bins</span> <span class="o">=</span> <span class="n">HilbertHuang1D</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
                <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">bin_spread</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span>
                <span class="n">smooth_sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">,</span>
                <span class="n">keep_first_IMF</span><span class="o">=</span><span class="n">keep_first_IMF</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IF</span> <span class="o">=</span> <span class="n">IF</span>
        <span class="c1"># if peaks_function == &#39;HH1D_weightAVG&#39;:</span>
        <span class="c1"># if peaks_function == &#39;HH1D_FOOOF&#39;:</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;bicoherence&quot;</span><span class="p">:</span>
            <span class="n">freqs</span><span class="p">,</span> <span class="n">amps</span> <span class="o">=</span> <span class="n">polyspectrum_frequencies</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="p">,</span>
                <span class="n">precision</span><span class="p">,</span>
                <span class="n">n_values</span><span class="o">=</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">flim1</span><span class="o">=</span><span class="p">(</span><span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">),</span>
                <span class="n">flim2</span><span class="o">=</span><span class="p">(</span><span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">),</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">common_freqs</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">pairs_most_frequent</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">))</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">common_freqs</span><span class="p">))))</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks_temp</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">max_freq</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;amp_idx = []</span>
<span class="sd">            for i in peaks_temp:</span>
<span class="sd">                amp_idx.append(flatten(freqs).index(i))</span>
<span class="sd">            amps_temp = np.array(flatten(amps))[amp_idx]</span>
<span class="sd">            amps_temp = list(amps_temp)</span>
<span class="sd">            # Select the n peaks with highest amplitude.</span>
<span class="sd">            peaks_temp = [x for _, x in sorted(zip(amps_temp, peaks_temp))][::-1][0:n_peaks]</span>
<span class="sd">            amps_temp = sorted(amps_temp)[::-1][0:n_peaks]&quot;&quot;&quot;</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;harmonic_recurrence&quot;</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">extract_welch_peaks</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="n">max_harm_freq</span><span class="p">,</span>
                <span class="n">extended_returns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">out_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
                <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span>
                <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="p">(</span>
                <span class="n">max_n</span><span class="p">,</span>
                <span class="n">peaks_temp</span><span class="p">,</span>
                <span class="n">amps_temp</span><span class="p">,</span>
                <span class="n">harms</span><span class="p">,</span>
                <span class="n">harm_peaks</span><span class="p">,</span>
                <span class="n">harm_peaks_fit</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">harmonic_recurrence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">,</span> <span class="n">min_harms</span><span class="o">=</span><span class="n">min_harms</span><span class="p">,</span> <span class="n">harm_limit</span><span class="o">=</span><span class="n">harm_limit</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">list_harmonics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">harms</span><span class="p">)</span>
                <span class="n">list_harmonics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_harmonics</span><span class="p">))))</span>
                <span class="n">list_harmonics</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">list_harmonics</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="n">harm_limit</span><span class="p">]</span>
                <span class="n">list_harmonics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">list_harmonics</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_harmonics</span> <span class="o">=</span> <span class="n">list_harmonics</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">harm_peaks_fit</span> <span class="o">=</span> <span class="n">harm_peaks_fit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_harmonic_recurrence</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">harm_peaks_fit</span><span class="p">)</span>
                <span class="c1"># Select the n peaks with maximum number of harmonic recurrence.</span>
                <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="n">peaks_temp</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>
                <span class="n">amps_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="n">amps_temp</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>
                <span class="c1"># amps_temp = sorted(amps_temp)[::-1][0:n_peaks]</span>
                <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">graph_harm_peaks</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span>
                        <span class="n">harm_peaks_fit</span><span class="p">,</span>
                        <span class="n">min_freq</span><span class="p">,</span>
                        <span class="n">max_freq</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                        <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">figname</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No peaks were detected. Consider increasing precision or number of harmonics&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;EIMC&quot;</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">extract_welch_peaks</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">sf</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="n">max_harm_freq</span><span class="p">,</span>
                <span class="n">extended_returns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">out_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_fft</span><span class="p">,</span>
                <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">,</span>
                <span class="n">rel_height</span><span class="o">=</span><span class="n">rel_height</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">IMC</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EIMC_all</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">endogenous_intermodulations</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">EIMC_order</span><span class="p">,</span> <span class="n">min_IMs</span><span class="o">=</span><span class="n">min_IMs</span><span class="p">)</span>
            <span class="n">IMC_freq</span> <span class="o">=</span> <span class="n">pairs_most_frequent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EIMC_all</span><span class="p">[</span><span class="s2">&quot;peaks&quot;</span><span class="p">],</span> <span class="n">n_peaks</span><span class="p">)</span>
            <span class="n">common_freqs</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">IMC_freq</span><span class="p">)</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">common_freqs</span><span class="p">))))</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks_temp</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">max_freq</span><span class="p">]</span>
            <span class="n">amp_idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">peaks_temp</span><span class="p">:</span>
                <span class="n">amp_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EIMC_all</span><span class="p">[</span><span class="s2">&quot;peaks&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EIMC_all</span><span class="p">[</span><span class="s2">&quot;amps&quot;</span><span class="p">]))[</span><span class="n">amp_idx</span><span class="p">]</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">amps_temp</span><span class="p">)</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">amps_temp</span><span class="p">,</span> <span class="n">peaks_temp</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>

            <span class="n">amps_temp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">amps_temp</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">graph_psd_peaks</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span>
                    <span class="n">peaks_temp</span><span class="p">,</span>
                    <span class="n">xmin</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                    <span class="n">xmax</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkgoldenrod&quot;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;PAC&quot;</span><span class="p">:</span>
            <span class="n">freqs</span><span class="p">,</span> <span class="n">amps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pac</span><span class="p">(</span>
                <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;duprelatour&quot;</span><span class="p">,</span>
                <span class="n">n_values</span><span class="o">=</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">drive_precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">max_drive_freq</span><span class="o">=</span><span class="n">max_freq</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">min_drive_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">sig_precision</span><span class="o">=</span><span class="n">precision</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">max_sig_freq</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">min_sig_freq</span><span class="o">=</span><span class="n">min_freq</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">low_fq_width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">high_fq_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">common_freqs</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">pairs_most_frequent</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">))</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">common_freqs</span><span class="p">))))</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks_temp</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">max_freq</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;amp_idx = []</span>
<span class="sd">            for i in peaks_temp:</span>
<span class="sd">                amp_idx.append(flatten(freqs).index(i))</span>
<span class="sd">            amps_temp = np.array(amps)[amp_idx]</span>
<span class="sd">            amps_temp = list(amps_temp)</span>
<span class="sd">            peaks_temp = [x for _, x in sorted(zip(amps_temp, peaks_temp))][::-1][</span>
<span class="sd">                0:n_peaks</span>
<span class="sd">            ]&quot;&quot;&quot;</span>

            <span class="n">amps_temp</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">==</span> <span class="s2">&quot;cepstrum&quot;</span><span class="p">:</span>
            <span class="n">cepstrum_</span><span class="p">,</span> <span class="n">quefrency_vector</span> <span class="o">=</span> <span class="n">cepstrum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">plot_cepstrum</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">peaks_temp_</span><span class="p">,</span> <span class="n">amps_temp_</span> <span class="o">=</span> <span class="n">cepstral_peaks</span><span class="p">(</span><span class="n">cepstrum_</span><span class="p">,</span> <span class="n">quefrency_vector</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">min_freq</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">max_freq</span><span class="p">)</span>
            <span class="n">peaks_temp_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">peaks_temp_</span><span class="p">))</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks_temp_</span><span class="p">]</span>
            <span class="n">amps_temp_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">amps_temp_</span><span class="p">))</span>
            <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">amps_temp_</span><span class="p">,</span> <span class="n">peaks_temp</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>
            <span class="n">amps_temp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">amps_temp_</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_peaks</span><span class="p">]</span>
        <span class="c1"># print(peaks_temp)</span>
        <span class="n">peaks_temp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="o">+</span> <span class="n">precision</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">peaks_temp</span><span class="p">]</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks_temp</span><span class="p">)</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amps_temp</span><span class="p">)</span>
        <span class="c1"># ensure no peaks are above max_freq and print warning indicating number of peaks removed</span>
        <span class="n">peaks_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_freq</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks_idx</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Warning: </span><span class="si">{}</span><span class="s2"> peaks were removed because they exceeded the maximum frequency of </span><span class="si">{}</span><span class="s2"> Hz&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks_idx</span><span class="p">),</span> <span class="n">max_freq</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="n">peaks_idx</span><span class="p">]</span>
        <span class="c1"># print(&#39;FINAL PEAKS&#39;, peaks)</span>
        <span class="k">if</span> <span class="n">peaks_function</span> <span class="o">!=</span> <span class="s2">&quot;PAC&quot;</span> <span class="ow">and</span> <span class="n">peaks_function</span> <span class="o">!=</span> <span class="s2">&quot;bicoherence&quot;</span><span class="p">:</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amps</span><span class="p">)[</span><span class="n">peaks_idx</span><span class="p">]</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amps</span><span class="p">)[</span><span class="n">peaks_idx</span><span class="p">]</span>
        <span class="c1"># filter out peaks that are not in min max range</span>
        <span class="n">peaks_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_freq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_freq</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="n">peaks_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">amps</span></div>


<div class="viewcode-block" id="compute_biotuner.compute_resonance">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.compute_resonance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_resonance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">harm_thresh</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">PPC_thresh</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
        <span class="n">smooth_fft</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">harmonicity_metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute resonances between pairs of frequency peaks in the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        harm_thresh : int, default=30</span>
<span class="sd">            The minimum harmonic similarity between a peak pair required to be considered a resonance.</span>
<span class="sd">            Must be a positive integer.</span>
<span class="sd">        PPC_thresh : float, default=0.6</span>
<span class="sd">            The minimum bispectral power correlation required for a peak pair to be considered a resonance.</span>
<span class="sd">            Must be a float between 0 and 1.</span>
<span class="sd">        smooth_fft : int, default=2</span>
<span class="sd">            The number of times to smooth the data using a Hamming window before computing the FFT.</span>
<span class="sd">            Must be a positive integer. When smooth_fft=1, nperseg=nfft.</span>
<span class="sd">        harmonicity_metric : str, default=&#39;harmsim&#39;</span>
<span class="sd">            The metric to use for computing the harmonic similarity between a pair of peaks.</span>
<span class="sd">            Choose between:</span>

<span class="sd">            - &#39;harmsim&#39;</span>
<span class="sd">            - &#39;subharm_tension&#39;</span>

<span class="sd">        delta_lim : int, default=50</span>
<span class="sd">            The maximum number of subharmonic intervals to consider when using the &#39;subharm_tension&#39; metric.</span>
<span class="sd">            Must be a positive integer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[float, List[Tuple[float, float]], List[float], List[float]]</span>
<span class="sd">            A tuple containing the following elements:</span>

<span class="sd">            - **resonance**: a float representing the mean weighted bicorrelation coefficient across all harmonic pairs that meet the specified criteria for harmonicity and PPC</span>
<span class="sd">            - **resonant_freqs**: a list of tuples, where each tuple contains two floats representing the frequencies of a pair of resonant harmonics that meet the specified criteria for harmonicity and PPC</span>
<span class="sd">            - **harm_all**: a list of floats representing the harmonic similarity metric between all possible harmonic pairs</span>
<span class="sd">            - **bicor_all**: a list of floats representing the bicorrelation coefficient between all possible harmonic pairs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span> <span class="o">!=</span> <span class="s2">&quot;EMD&quot;</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span> <span class="o">!=</span> <span class="s2">&quot;EMD_fast&quot;</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span> <span class="o">!=</span> <span class="s2">&quot;harmonic_recurrence&quot;</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span> <span class="o">!=</span> <span class="s2">&quot;FOOOF&quot;</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Peaks extraction function </span><span class="si">{}</span><span class="s2"> is not compatible with resonance metrics&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No peaks in the biotuner object. Please use peaks_extraction method first&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span>
            <span class="n">nfft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sf</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span>
            <span class="n">nperseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nfft</span> <span class="o">/</span> <span class="n">smooth_fft</span><span class="p">)</span>
        <span class="n">max_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
        <span class="n">freq1</span><span class="p">,</span> <span class="n">freq2</span><span class="p">,</span> <span class="n">bispec</span> <span class="o">=</span> <span class="n">polycoherence</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">flim1</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_peak</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">],</span>
            <span class="n">flim2</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_peak</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
            <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">harm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bicor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weighted_bicor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">resonant_freqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">harm_all</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bicor_all</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">harmonicity_metric</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                <span class="n">harm_</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">harmonicity_metric</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">harm_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_subharmonic_tension</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">harm_</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">harm_</span>
            <span class="c1"># Determine the number of decimal places you want to consider</span>
            <span class="n">n_decimals</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Convert freq1 to a list of rounded values</span>
            <span class="n">freq1_rounded</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n_decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">freq1</span><span class="p">]</span>

            <span class="c1"># Round the pair values</span>
            <span class="n">pair_rounded</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_decimals</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_decimals</span><span class="p">))</span>

            <span class="c1"># Now use the rounded values to find the indices</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="n">freq1_rounded</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pair_rounded</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="n">freq1_rounded</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pair_rounded</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># idx1 = (np.abs(np.array(freq1) - pair[0])).argmin()</span>
            <span class="c1"># idx2 = (np.abs(np.array(freq1) - pair[1])).argmin()</span>
            <span class="n">bicor_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">bispec</span><span class="p">[</span><span class="n">idx1</span><span class="p">][</span><span class="n">idx2</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">bicor_</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">harm_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">harm_</span><span class="p">)</span>
                <span class="n">bicor_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bicor_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">harm_</span> <span class="o">&gt;</span> <span class="n">harm_thresh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bicor_</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">bicor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bicor_</span><span class="p">)</span>
                    <span class="n">harm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">harm_</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">harmonicity_metric</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                        <span class="n">weighted_bicor</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">harm_</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="n">bicor_</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">harmonicity_metric</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                        <span class="n">weighted_bicor</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">harm_</span><span class="p">)</span> <span class="o">*</span> <span class="n">bicor_</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bicor_</span> <span class="o">&gt;</span> <span class="n">PPC_thresh</span><span class="p">:</span>
                        <span class="n">resonant_freqs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># resonance = np.corrcoef(harm_sim, bicor)[0][1]</span>
        <span class="n">resonance_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weighted_bicor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resonance</span> <span class="o">=</span> <span class="n">resonance_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resonant_freqs</span> <span class="o">=</span> <span class="n">resonant_freqs</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">scale_from_pairs</span><span class="p">(</span><span class="n">resonant_freqs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_tuning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">scale</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PPC_bicor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bicor_all</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resonance_</span><span class="p">,</span> <span class="n">resonant_freqs</span><span class="p">,</span> <span class="n">harm_all</span><span class="p">,</span> <span class="n">bicor_all</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;Listening methods&quot;&quot;&quot;</span>

<div class="viewcode-block" id="compute_biotuner.listen_scale">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.listen_scale">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">listen_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">fund</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Play a scale of notes using pygame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : str or np.ndarray</span>
<span class="sd">            The scale to play.</span>
<span class="sd">            If `scale` is a string, it can be one of:</span>

<span class="sd">            - &#39;peaks&#39;: the scale is set to the biotuner object&#39;s `peaks_ratios` attribute</span>
<span class="sd">            - &#39;diss&#39;: the scale is set to the biotuner object&#39;s `diss_scale` attribute</span>
<span class="sd">            - &#39;HE&#39;: the scale is set to the biotuner object&#39;s `HE_scale` attribute</span>

<span class="sd">            If `scale` is a numpy array, it should be an array of scale</span>
<span class="sd">            ratios.</span>
<span class="sd">        fund : float, default=250</span>
<span class="sd">            The fundamental frequency of the scale.</span>
<span class="sd">        length : float, default=500</span>
<span class="sd">            The length of each note in milliseconds.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame_lib</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;The &#39;pygame&#39; package is required for this functionality. Install it with:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;    pip install pygame</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pygame_lib</span> <span class="o">=</span> <span class="n">pygame</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;peaks&quot;</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaks_ratios</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;diss&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diss_scale</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Dissonance Curve scale available&quot;</span><span class="p">)</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;HE&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HE_scale</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Harmonic Entropy scale available&quot;</span><span class="p">)</span>
                <span class="k">pass</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Scale:&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">scale</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">fund</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">note</span> <span class="o">=</span> <span class="n">make_chord</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">note</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">note</span><span class="p">,</span> <span class="n">note</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">sound</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sndarray</span><span class="o">.</span><span class="n">make_sound</span><span class="p">(</span><span class="n">note</span><span class="p">)</span>
            <span class="n">sound</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">loops</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxtime</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fade_ms</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sound</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span> <span class="o">*</span> <span class="n">length</span><span class="p">))</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic method to fit all Biotuner methods&quot;&quot;&quot;</span>

<div class="viewcode-block" id="compute_biotuner.fit_all">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.fit_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">compute_diss</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_HE</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_peaks_extension</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit biotuning metrics to input data using various optional computations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array, shape (n_samples,)</span>
<span class="sd">            A single time series of EEG data.</span>
<span class="sd">        compute_diss : bool, optional, default=True</span>
<span class="sd">            If True, compute the dissonance curve.</span>
<span class="sd">        compute_HE : bool, optional, default=True</span>
<span class="sd">            If True, compute the harmonic entropy.</span>
<span class="sd">        compute_peaks_extension : bool, optional, default=True</span>
<span class="sd">            If True, compute the peaks extension using the multi-consonant harmonic fit method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        biotuning : Biotuning object</span>
<span class="sd">            The fitted biotuning object containing the computed metrics.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">biotuning</span> <span class="o">=</span> <span class="n">compute_biotuner</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
            <span class="n">peaks_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">biotuning</span><span class="o">.</span><span class="n">peaks_extraction</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">biotuning</span><span class="o">.</span><span class="n">compute_peaks_metrics</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">compute_diss</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">biotuning</span><span class="o">.</span><span class="n">compute_diss_curve</span><span class="p">(</span><span class="n">input_type</span><span class="o">=</span><span class="s2">&quot;peaks&quot;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_peaks_extension</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">biotuning</span><span class="o">.</span><span class="n">peaks_extension</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;multi_consonant_harmonic_fit&quot;</span><span class="p">,</span>
                <span class="n">harm_function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
                <span class="n">cons_limit</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_HE</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">biotuning</span><span class="o">.</span><span class="n">compute_harmonic_entropy</span><span class="p">(</span><span class="n">input_type</span><span class="o">=</span><span class="s2">&quot;extended_peaks&quot;</span><span class="p">,</span> <span class="n">plot_entropy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">biotuning</span></div>


<div class="viewcode-block" id="compute_biotuner.info">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.compute_biotuner.info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scales</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">whatever</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;METRICS&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span></div>
</div>



<div class="viewcode-block" id="fit_biotuner">
<a class="viewcode-back" href="../../api/biotuner_object.html#biotuner.biotuner_object.fit_biotuner">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_biotuner</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">bt_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute biotuner metrics on a single time series using a specified set of parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts : array, shape (n_samples,)</span>
<span class="sd">        A single time series of EEG data.</span>
<span class="sd">    bt_dict : dict</span>
<span class="sd">        A dictionary containing the parameters to compute biotuner metrics. See the compute_biotuner and</span>
<span class="sd">        tuning_to_metrics functions documentation for details on the required keys and values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bt_dict : dict</span>
<span class="sd">        The modified input dictionary with the computed biotuner metrics added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the biotuner object</span>
    <span class="n">biotuning</span> <span class="o">=</span> <span class="n">compute_biotuner</span><span class="p">(</span>
        <span class="n">sf</span><span class="o">=</span><span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;sf&quot;</span><span class="p">],</span>
        <span class="n">peaks_function</span><span class="o">=</span><span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;peaks_function&quot;</span><span class="p">],</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">],</span>
        <span class="n">n_harm</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">ratios_n_harms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">ratios_inc_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ratios_inc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Extract the peaks from the time series</span>
    <span class="n">biotuning</span><span class="o">.</span><span class="n">peaks_extraction</span><span class="p">(</span>
        <span class="n">ts</span><span class="p">,</span>
        <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ratios_extension</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="o">=</span><span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;fmax&quot;</span><span class="p">],</span>
        <span class="n">n_peaks</span><span class="o">=</span><span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;n_peaks&quot;</span><span class="p">],</span>
        <span class="n">min_freq</span><span class="o">=</span><span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;fmin&quot;</span><span class="p">],</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">min_harms</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute the peaks metrics and resonance</span>
    <span class="n">biotuning</span><span class="o">.</span><span class="n">compute_peaks_metrics</span><span class="p">(</span><span class="n">n_harm</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;delta_lim&quot;</span><span class="p">])</span>

    <span class="c1"># Convert the peaks ratios and peaks metrics to a dictionary of biotuner metrics</span>
    <span class="n">bt_metrics</span> <span class="o">=</span> <span class="n">tuning_to_metrics</span><span class="p">(</span><span class="n">biotuning</span><span class="o">.</span><span class="n">peaks_ratios</span><span class="p">)</span>
    <span class="n">bt_metrics</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">biotuning</span><span class="o">.</span><span class="n">peaks_metrics</span><span class="p">)</span>

    <span class="c1"># Remove unneeded metrics from the dictionary</span>
    <span class="k">del</span> <span class="n">bt_metrics</span><span class="p">[</span><span class="s2">&quot;harm_pos&quot;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">bt_metrics</span><span class="p">[</span><span class="s2">&quot;euler&quot;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">bt_metrics</span><span class="p">[</span><span class="s2">&quot;common_harm_pos&quot;</span><span class="p">]</span>

    <span class="c1"># Add additional metadata to the dictionary</span>
    <span class="n">peaks_euler</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">biotuning</span><span class="o">.</span><span class="n">peaks</span><span class="p">]</span>
    <span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;peaks_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">biotuning</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;n_peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">biotuning</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">bt_dict</span><span class="p">[</span><span class="s2">&quot;euler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler</span><span class="p">(</span><span class="o">*</span><span class="n">peaks_euler</span><span class="p">)</span>

    <span class="c1"># Update the bt_dict dictionary with the computed biotuner metrics</span>
    <span class="n">bt_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bt_metrics</span><span class="p">)</span>

    <span class="c1"># Return the modified bt_dict dictionary</span>
    <span class="k">return</span> <span class="n">bt_dict</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Antoine Bellemare & François Lespinasse. This documentation and code are licensed under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023–2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>